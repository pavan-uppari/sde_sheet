{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to Striver SDE Sheet \ud83e\udd17. </p>"},{"location":"#emoji-reference","title":"Emoji Reference","text":"<p>\u2753- Problem Statement \ud83e\udde0 - Algorithm \ud83d\udc0d - Python \ud83e\udd80 - Rust \ud83d\udcd8 - TUF link \ud83d\udcbb - Platform link</p>"},{"location":"#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p><code>s</code> or<code>/</code> - Search <code>n</code> - next page <code>p</code> - previous page  </p> <p>Click <code>n</code> for first problem.</p>"},{"location":"arrays/arrays1/","title":"Part1","text":""},{"location":"arrays/arrays1/#set-matrix-zeroes","title":"Set Matrix Zeroes","text":"<p>\u2753: Given a matrix if an element in the matrix is 0 then you will have to set its entire column and row to 0 and then return the matrix. \ud83e\udde0: 1. First find the indexes of rows and columns where 0 is present 2. Iterate through matrix again to make relevant items to zero</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -&gt; None:\n        r: set[int] = set()\n        c: set[int] = set()\n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    r.add(i)\n                    c.add(j)\n        for i in range(m):\n            for j in range(n):\n                if (i in r) or (j in c):\n                    matrix[i][j] = 0\n</code></pre> <pre><code>use std::collections::HashSet;\n\nimpl Solution {\n    pub fn set_zeroes(matrix: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n        let mut r: HashSet&lt;usize&gt; = HashSet::new();\n        let mut c: HashSet&lt;usize&gt; = HashSet::new();\n\n        let n = matrix.len();\n        let m = matrix[0].len();\n\n        for i in 0..n {\n            for j in 0..m {\n                if matrix[i][j] == 0 {\n                    r.insert(i);\n                    c.insert(j);\n                }\n            }\n        }\n\n        for i in 0..n {\n            for j in 0..m {\n                if r.contains(&amp;i) || c.contains(&amp;j) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays1/#next-permutation","title":"Next Permutation","text":"<p>Coming Soon</p>"},{"location":"arrays/arrays1/#pascals-triangle","title":"Pascals Triangle","text":"<p>\u2753: In Pascal\u2019s triangle, each number is the sum of the two numbers directly above it as shown in the figure below: Given the number of rows n. Print the first n rows of Pascal\u2019s triangle.. </p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def generate(self, numRows: int) -&gt; List[List[int]]:\n        result = [[1]]\n        if numRows == 1:\n            return result\n        for _ in range(2, numRows + 1):\n            result.append(self.next_pascal_row(result[-1]))\n        return result\n\n    def next_pascal_row(self, row: list[int]):\n        result = [1]\n        for i in range(1, len(row)):\n            result.append(row[i] + row[i - 1])\n        result.append(1)\n        return result\n</code></pre> <pre><code>impl Solution {\n    pub fn generate(n: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let mut res: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![1]];\n\n        if n == 1 {\n            return res;\n        }\n        for i in 2..=n {\n            let last = res.last().unwrap();\n            res.push(Solution::next_row(last));\n        }\n        res\n    }\n\n    pub fn next_row(last: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n        let mut res: Vec&lt;i32&gt; = vec![1];\n        for i in 1..last.len() {\n            res.push(last[i] + last[i - 1]);\n        }\n        res.push(1);\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays1/#kadanes-algorithm","title":"Kadanes Algorithm","text":"<p>\u2753: Given an integer array arr, find the contiguous subarray (containing at least one number) which has the largest sum and returns its sum</p> \ud83d\udc0d\ud83e\udd80 <pre><code># TODO Print actual sub array as follow up question\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -&gt; int:\n        if len(nums) == 1:\n            return nums[0]\n        maxi_sum = nums[0]\n        curr_sum = nums[0]\n        for item in nums[1:]:\n            curr_sum = max(item, curr_sum + item)\n            maxi_sum = max(maxi_sum, curr_sum)\n        return maxi_sum\n</code></pre> <pre><code>use std::cmp::max;\n\nimpl Solution {\n    pub fn max_sub_array(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        let mut res = nums[0];\n        let mut curr = nums[0];\n\n        for num in &amp;nums[1..] {\n            if curr &lt; 0 {\n                curr = 0;\n            }\n            curr += num;\n            res = max(res, curr);\n        }\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays1/#sort-list-of-0s1s2s","title":"Sort list Of 0s,1s,2s","text":"<p>\u2753: Given an array consisting of only 0s, 1s, and 2s. Write a program to in-place sort the array without using inbuilt sort functions. ( Expected: Single pass-O(N) and constant space)</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def sortColors(self, nums: List[int]) -&gt; None:\n        li = 0\n        ri = len(nums) - 1\n\n        curr = li\n        while curr &lt;= ri:\n            if nums[curr] == 0:\n                nums[curr], nums[li] = nums[li], nums[curr]\n                li += 1\n                curr += 1\n            elif nums[curr] == 2:\n                nums[curr], nums[ri] = nums[ri], nums[curr]\n                ri -= 1\n            elif nums[curr] == 1:\n                curr += 1\n</code></pre> <pre><code>impl Solution {\n    pub fn sort_colors(nums: &amp;mut Vec&lt;i32&gt;) {\n        let n = nums.len();\n        let mut l: usize = 0;\n        let mut r: usize = n - 1;\n        let mut curr: usize = 0;\n\n        while curr &lt;= r {\n            if nums[curr] == 0 {\n                nums.swap(l, curr);\n                l += 1;\n                curr += 1;\n            } else if nums[curr] == 2 {\n                nums.swap(r, curr);\n                if r == 0 {\n                    break;\n                }\n                r -= 1;\n            } else {\n                curr += 1\n            }\n        }\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays1/#stock-buy-and-sell","title":"Stock Buy and Sell","text":"<p>\u2753: You are given an array of prices where prices[i] is the price of a given stock on an ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def maxProfit(self, prices: List[int]) -&gt; int:\n        n = len(prices)\n        if n == 1:\n            return 0\n        result = 0\n        curr_mini = prices[0]\n        for item in prices[1:]:\n            curr_mini = min(curr_mini, item)\n            result = max(result, item - curr_mini)\n        return result\n</code></pre> <pre><code>use std::cmp::{max, min};\n\nimpl Solution {\n    pub fn max_profit(prices: Vec&lt;i32&gt;) -&gt; i32 {\n        let mut mini: i32 = i32::MAX;\n        let mut res: i32 = 0;\n        for price in prices {\n            mini = min(mini, price);\n            res = max(res, price - mini);\n        }\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays2/","title":"Part2","text":""},{"location":"arrays/arrays2/#rotate-matrix","title":"Rotate Matrix","text":"<p>\u2753: Given a matrix, your task is to rotate the matrix 90 degrees clockwise.</p> \ud83d\udc0d\ud83e\udd80 <pre><code># Using extra memory approach\ndef method(matrix):\n    \"\"\"\n    logic - i,j = j,n-i-1\n    \"\"\"\n\n    n = len(matrix)\n    res = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            res[j][n - i - 1] = matrix[i][j]\n    return res\n\n\n# Better approach without using extra memory\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -&gt; None:\n        \"\"\"\n        1. Transpose the matrix\n        2. Reverse each row\n        \"\"\"\n        for i in range(len(matrix)):\n            for j in range(i + 1, len(matrix[0])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(len(matrix)):\n            matrix[i] = matrix[i][::-1]\n        return matrix\n</code></pre> <pre><code>impl Solution {\n    pub fn rotate(matrix: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n        let n = matrix.len();\n        let m = matrix[0].len();\n\n        for i in 0..n {\n            for j in i + 1..m {\n                let temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n\n        for i in 0..n {\n            matrix[i].reverse();\n        }\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays2/#merge-overlapping-sub-intervals","title":"Merge Overlapping Sub Intervals","text":"<p>\u2753: Given an array of intervals, merge all the overlapping intervals and return an array of non-overlapping intervals.</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def merge(self, nums: List[List[int]]) -&gt; List[List[int]]:\n        \"\"\"\n        1. Sort the list\n        2. Create res list\n        3. Iterate through list and compare the item with the last item of res to check if merging is possible\n        4. If possible, update the last item of res, else add current item to res\n        \"\"\"\n        nums.sort()\n        res = [nums[0]]\n        for i in range(1, len(nums)):\n            if res[-1][-1] &gt;= nums[i][0]:\n                res[-1] = [res[-1][0], max(res[-1][1], nums[i][1])]\n            else:\n                res.append(nums[i])\n        return res\n</code></pre> <pre><code>use std::cmp::max;\n\nimpl Solution {\n    pub fn merge(intervals: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let mut intervals = intervals;\n\n        intervals.sort();\n        let mut res: Vec&lt;Vec&lt;i32&gt;&gt; = vec![intervals[0].clone()];\n\n        for interval in &amp;intervals[1..] {\n            let last = res.last().unwrap().to_vec();\n            if interval[0] &lt;= last[1] {\n                res.pop();\n                res.push(vec![last[0], max(last[1], interval[1])]);\n            } else {\n                res.push(interval.to_vec());\n            }\n        }\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays2/#merge-2-sorted-arrays-without-extra-space","title":"Merge 2 sorted arrays without extra space","text":"<p>\u2753: Given two sorted arrays arr1[] and arr2[] of sizes n and m in non-decreasing order. Merge them in sorted order. Modify arr1 so that it contains the first N elements and modify arr2 so that it contains the last M elements.</p> \ud83d\udc0d\ud83e\udd80 <pre><code># Check another approach - Using gap method\n\n\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n        \"\"\"\n        1. Iterate throught both the arrays, if array2 element is less than array1 element,\n            then pop last item(zero) from arr1 and insert arr2 item into arr1 at that index\n        2. Make a count of number of zeros removed in that process\n        3. At the end of that iteration, there might be some large elements left over in arr2.\n        4. Insert them into arr1\n        \"\"\"\n        i = j = 0\n        zeroes_removed = 0\n        while i &lt; m + n and j &lt; n:\n            if nums1[i] &gt; nums2[j]:\n                zeroes_removed += 1\n                nums1.pop()\n                nums1.insert(i, nums2[j])\n                j += 1\n            i += 1\n        for i in range(m + zeroes_removed, m + n):\n            nums1[i] = nums2[j]\n            j += 1\n</code></pre> <pre><code>impl Solution {\n    pub fn merge(nums1: &amp;mut Vec&lt;i32&gt;, m: i32, nums2: &amp;mut Vec&lt;i32&gt;, n: i32) {\n        let mut i: usize = 0;\n        let mut j: usize = 0;\n        let um: usize = m as usize;\n        let un: usize = n as usize;\n\n        while i &lt; um + un &amp;&amp; j &lt; un {\n            if nums2[j] &lt; nums1[i] {\n                nums1.pop();\n                nums1.insert(i, nums2[j]);\n                j += 1;\n            }\n            i += 1;\n        }\n\n        for i in um + j..um + un {\n            nums1[i] = nums2[j];\n            j += 1;\n        }\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays2/#duplicate-in-array-of-n1-integers","title":"Duplicate in array of n+1 integers","text":"<p>\u2753: Given an array of N + 1 size, where each element is between 1 and N. Assuming there is only one duplicate number, your task is to find the duplicate number.</p> <p>\ud83e\udde0: Floyd's Cycle Detection 1. Slow moves one point at a time 2. Fast moves 2 points at a time. 3. After they colloide, if we reset first pointer, and move that and slow pointer at a time, they will colloide at our result.</p> <p>Please check  here for formula and intuition</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def findDuplicate(self, nums: List[int]) -&gt; int:\n        slow = fast = 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while True:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n            if slow == slow2:\n                return slow\n</code></pre> <pre><code>use std::collections::HashSet;\n\nimpl Solution {\n    pub fn find_duplicate(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        let mut set: HashSet&lt;i32&gt; = HashSet::new();\n\n        for num in nums {\n            if set.contains(&amp;num) {\n                return num;\n            }\n            set.insert(num);\n        }\n        return 1;\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays2/#repeating-and-missing-number","title":"Repeating and Missing number","text":"<p>\u2753: You are given a read-only array of N integers with values also in the range [1, N] both inclusive. Each integer appears exactly once except A which appears twice and B which is missing. The task is to find the repeating and missing numbers A and B where A repeats twice and B is missing.</p> <p>\ud83e\udde0: Simple Maths Equations 1. Find sum of n numbers and find X - Y value. (X- Repeating, Y - Missing) 2. Find sum of squares of n numbers and form second equation. (X2 - Y2 = (X+Y)(X-Y)). From which we can get X + Y value 3. From those 2 equations, X and Y can be found out</p> <p>Please check here for formula and intuition</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def missingNumber(self, nums: list[int]) -&gt; list[int, int]:\n        n = len(nums)\n        Sn = n * (n + 1) // 2\n        S2n = n * (n + 1) * (2 * n + 1) / 6\n\n        my_Sn = my_S2n = 0\n\n        for num in nums:\n            my_Sn += num\n            my_S2n += num * num\n\n        # equation1 - X+Y = (my_S2n - S2n) / (my_Sn-Sn)\n\n        equation_1_value = (my_S2n - S2n) / (my_Sn - Sn)\n\n        # equation2 - X-Y = my_Sn- Sn\n        equation_2_value = my_Sn - Sn\n\n        return [\n            (equation_1_value + equation_2_value) // 2,\n            (equation_1_value - equation_2_value) // 2,\n        ]\n\n\nobj = Solution()\nassert obj.missingNumber([3, 1, 2, 5, 3]) == [3, 4]\nassert obj.missingNumber([3, 1, 2, 5, 4, 6, 7, 5]) == [5, 8]\n</code></pre> <pre><code>fn find_duplicate(nums: Vec&lt;i32&gt;) -&gt; (i32, i32) {\n    let n: i32 = nums.len() as i32;\n    let sn: i32 = n * (n + 1) / 2;\n    let s2n: i32 = n * (n + 1) * (2 * n + 1) / 6;\n\n    let mut c_sn = 0;\n    let mut c_s2n = 0;\n    for num in nums {\n        c_sn += num;\n        c_s2n += num * num;\n    }\n\n    let eq1 = (c_s2n - s2n) / (c_sn - sn);\n    let eq2 = c_sn - sn;\n\n    ((eq1 + eq2) / 2, (eq1 - eq2) / 2)\n}\n\nfn main() {\n    assert_eq!((3, 4), find_duplicate(vec![3, 1, 2, 5, 3]));\n    assert_eq!((5, 8), find_duplicate(vec![3, 1, 2, 5, 4, 6, 7, 5]));\n}\n</code></pre> <p>\ud83d\udcd8</p>"},{"location":"arrays/arrays2/#inversion-of-array","title":"Inversion of Array","text":"<p>Coming Soon</p>"},{"location":"arrays/arrays3/","title":"Part3","text":""},{"location":"arrays/arrays3/#search-in-2d-matrix","title":"Search in 2d Matrix","text":"<p>\u2753: Search in a sorted 2D matrix</p> <p>Approach 1: Simple Maths Equations 1. Iterate through each row and check whether target can exist in that row or not 2. If yes, do a binary search 3. From those 2 equations, X and Y can be found out</p> <p>Time Complexity -&gt; O(n + logm)</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def searchMatrix(self, matrix: list[list[int]], target: int) -&gt; bool:\n        for row in matrix:\n            if row[0] &lt;= target &lt;= row[-1]:\n                return self.binary_search(row, target)\n        return False\n\n    def binary_search(self, row, target) -&gt; bool:\n        n = len(row)\n        low, high = 0, n - 1\n        while low &lt;= high:\n            mid = (low + high) // 2\n            if row[mid] == target:\n                return True\n            elif row[mid] &lt; target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return False\n\n\n\"\"\"\nApproach2 -&gt;\nDo binary search on entire matrix, Trick Formula -&gt; from mid integer, row and column are mid//m and mid%m.\n\nTime Complexity -&gt; O(logn + logm)\n\"\"\"\n\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        n, m = len(matrix), len(matrix[0])\n        low, high = 0, m * n - 1\n        while low &lt;= high:\n            mid = (low + high) // 2\n            r, c = mid // m, mid % m\n            if matrix[r][c] == target:\n                return True\n            elif matrix[r][c] &lt; target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return False\n</code></pre> <pre><code>impl Solution {\n    pub fn search_matrix(matrix: Vec&lt;Vec&lt;i32&gt;&gt;, target: i32) -&gt; bool {\n        let n = matrix.len();\n        let m = matrix[0].len();\n\n        let (mut low, mut high) = (0, n * m - 1);\n\n        while low &lt;= high {\n            let mid = (low + high) / 2;\n            let (r, c) = (mid / m, mid % m);\n            if matrix[r][c] == target {\n                return true;\n            } else if matrix[r][c] &lt; target {\n                low = mid + 1;\n            } else {\n                if mid == 0 {\n                    break;\n                }\n                high = mid - 1;\n            }\n        }\n        false\n    }\n}\n</code></pre> <p>\ud83d\udcd8\ud83d\udcbb</p>"},{"location":"arrays/arrays3/#powxn","title":"Pow(x,n)","text":"<p>\u2753: Given a double x and integer n, calculate x raised to power n. Basically Implement pow(x, n).</p> <p>\ud83e\udde0 <pre><code>6 ** 5\n\nans = 6\n6 ** 4\n\n(6 * 6) ** 2\n36 ** 2\n(36**36) ** 1\nans = ans * 36*36\n\n1. If power if odd, multiply the curr number to ans and reduce curr number by 1\n2. If power if even, square the curr number and reduce the power by half\n</code></pre></p> <p>TC - O(logn) SC - O(1)</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def myPow(self, x: float, n: int) -&gt; float:\n        if n == 0:\n            return 1.0\n        res = 1.0\n        dummy_n = abs(n)\n        while dummy_n &gt; 1:\n            if dummy_n % 2:\n                res *= x\n                dummy_n -= 1\n            else:\n                x *= x\n                dummy_n //= 2\n        res *= x\n        if n &lt; 0:\n            res = 1 / res\n        return res\n</code></pre> <pre><code>impl Solution {\n    pub fn my_pow(x: f64, n: i32) -&gt; f64 {\n        if n == 0 {\n            return 1.0;\n        }\n\n        let mut x = x;\n        let ox = x.clone(); //original x\n        let mut dn = if n == i32::MIN { i32::MAX } else { n.abs() }; //duplicate n\n        let mut res = 1.0;\n\n        while dn &gt; 1 {\n            if dn % 2 == 1 {\n                res *= x;\n                dn -= 1;\n            } else {\n                x *= x;\n                dn /= 2;\n            }\n        }\n        res *= x;\n        if n == i32::MIN {\n            res *= ox;\n        }\n        if n &lt; 0 {\n            res = 1.0 / res;\n        }\n\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8\ud83d\udcbb</p>"},{"location":"arrays/arrays3/#majority-element-n2-times","title":"Majority Element (&gt;n/2 times)","text":"<p>\u2753: Given an array of N integers, write a program to return an element that occurs more than N/2 times in the given array. You may consider that such an element always exists in the array.</p> \ud83d\udc0d\ud83e\udd80 <pre><code># Cancelling out if count if zero. If it is majority element, count won't become zero (won't be cancelled out)\nclass Solution:\n    def majorityElement(self, nums: List[int]) -&gt; int:\n        curr = nums[0]\n        count = 1\n        for num in nums[1:]:\n            if count == 0:\n                curr = num\n                count = 1\n            elif num == curr:\n                count += 1\n            else:\n                count -= 1\n        return curr\n</code></pre> <pre><code>impl Solution {\n    pub fn majority_element(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        let mut res = nums[0];\n        let mut count = 1;\n\n        for &amp;num in &amp;nums[1..] {\n            if num == res {\n                count += 1\n            } else {\n                count -= 1;\n                if count == 0 {\n                    res = num;\n                    count = 1;\n                }\n            }\n        }\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays3/#majority-element-n3-times","title":"Majority Element (&gt;n/3 times)","text":"<p>\u2753: Given an array of N integers. Find the elements that appear more than N/3 times in the array. If no such element exists, return an empty vector.</p> <p>\ud83e\udde0: Same as previous majority element algo. The difference is we apply the same algo for 2 elements and at the end we will find out which occurs more than n/3 times manually again.</p> <p></p> <p>Time - O(2n) Space - O(1)</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def majorityElement(self, nums: List[int]) -&gt; List[int]:\n        e1 = e2 = None\n        c1 = c2 = 0\n        for num in nums:\n            if c1 == 0 and e2 != num:\n                e1 = num\n                c1 = 1\n            elif c2 == 0 and e1 != num:\n                e2 = num\n                c2 = 1\n            elif num == e1:\n                c1 += 1\n            elif num == e2:\n                c2 += 1\n            else:\n                c1 -= 1\n                c2 -= 1\n        c1 = c2 = 0\n        for num in nums:\n            if num == e1:\n                c1 += 1\n            elif num == e2:\n                c2 += 1\n        n = len(nums)\n        res = []\n        if e1 is not None and c1 &gt; n // 3:\n            res.append(e1)\n        if e2 is not None and c2 &gt; n // 3:\n            res.append(e2)\n        return res\n</code></pre> <pre><code>impl Solution {\n    pub fn majority_element(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n        let (mut e1, mut e2, mut c1, mut c2) = (0, 1, 0, 0);\n\n        for &amp;num in &amp;nums {\n            if num == e1 {\n                c1 += 1\n            } else if num == e2 {\n                c2 += 1\n            } else if c1 == 0 {\n                e1 = num;\n                c1 = 1;\n            } else if c2 == 0 {\n                e2 = num;\n                c2 = 1;\n            } else {\n                c1 -= 1;\n                c2 -= 1;\n            }\n        }\n\n        let n = nums.len();\n        let (mut c1, mut c2) = (0, 0);\n        for &amp;num in &amp;nums {\n            if num == e1 {\n                c1 += 1;\n            }\n            if num == e2 {\n                c2 += 1;\n            }\n        }\n        let mut res: Vec&lt;i32&gt; = vec![];\n        if c1 &gt; n / 3 {\n            res.push(e1)\n        }\n        if c2 &gt; n / 3 {\n            res.push(e2)\n        }\n\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays3/#grid-unique-paths","title":"Grid Unique Paths","text":"<p>\u2753: Given a matrix m X n, count paths from left-top to the right bottom of a matrix with the constraints that from each cell you can either only move to the rightward direction or the downward direction.</p> <p></p> \ud83d\udc0d\ud83e\udd80 <pre><code># Brute Force\n# Time - m!*n!\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        \"\"\"\n        1. If curr indexes crossed the boundary, return 0\n        2. If curr indexes are at destination, return 1\n        3. Recursively perform the above by increasing the currrent indexes\n        \"\"\"\n        return self.helper(0, 0, m, n)\n\n    def helper(self, m1, n1, m, n):\n        if m1 &gt;= m or n1 &gt;= n:\n            return 0\n        if m1 == m - 1 and n1 == n - 1:\n            return 1\n        return self.helper(m1, n1 + 1, m, n) + self.helper(m1 + 1, n1, m, n)\n\n\n# Optimal - DP Approach\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        \"\"\"\n        Idea is same as above, but the difference is, once you compute the value of a node, store it and use that value if that node is called again\n        \"\"\"\n        return self.helper(0, 0, m, n, {})\n\n    def helper(self, m1, n1, m, n, dp):\n        if (m1, n1) in dp:\n            return dp[(m1, n1)]\n        if m1 &gt;= m or n1 &gt;= n:\n            return 0\n        if m1 == m - 1 and n1 == n - 1:\n            return 1\n        dp[(m1, n1)] = self.helper(m1, n1 + 1, m, n, dp) + self.helper(\n            m1 + 1, n1, m, n, dp\n        )\n        return dp[(m1, n1)]\n</code></pre> <pre><code>use std::collections::HashMap;\n\nimpl Solution {\n    pub fn unique_paths(m: i32, n: i32) -&gt; i32 {\n        let mut dp: HashMap&lt;(i32, i32), i32&gt; = HashMap::new();\n        return Solution::helper(0, 0, m, n, &amp;mut dp);\n    }\n\n    fn helper(r: i32, c: i32, m: i32, n: i32, dp: &amp;mut HashMap&lt;(i32, i32), i32&gt;) -&gt; i32 {\n        if dp.contains_key(&amp;(r, c)) {\n            return dp[&amp;(r, c)];\n        }\n\n        if r == m || c == n {\n            return 0;\n        }\n        if r == m - 1 &amp;&amp; c == n - 1 {\n            return 1;\n        }\n\n        let left = Solution::helper(r, c + 1, m, n, dp);\n        let right = Solution::helper(r + 1, c, m, n, dp);\n\n        dp.insert((r, c), left + right);\n        return dp[&amp;(r, c)];\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays3/#reverse-pairs","title":"Reverse Pairs","text":"<p>Coming Soon</p>"},{"location":"arrays/arrays4/","title":"Part4","text":""},{"location":"arrays/arrays4/#2-sum","title":"2 Sum","text":"<p>\u2753: Check if a pair with given sum exists in Array \ud83e\udde0: 1. Store the current element with index in hash map 2. while iterating through arrays, check whether curr - sum in hashmap</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            if target - num in seen:\n                return [seen[target - num], i]\n            seen[num] = i\n</code></pre> <pre><code>use std::collections::HashMap;\n\nimpl Solution {\n    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {\n        let mut seen: HashMap&lt;i32, i32&gt; = HashMap::new();\n\n        for i in 0..nums.len() {\n            let ii: i32 = i as i32;\n            let req = target - nums[i];\n            if seen.contains_key(&amp;req) {\n                return vec![seen[&amp;req], ii];\n            }\n            seen.insert(nums[i], ii);\n        }\n        vec![]\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays4/#4-sum","title":"4 Sum","text":"<p>\u2753: Find Quads that add up to a target value \ud83e\udde0: 1. Sort the array and use 4 pointers. 2. Fix i and j pointers and put left and right pointers at the left and right end of remaining array 3. To avoid duplicate quads, while moving the pointers, move them only if they are not equal to their previous elements 4. If 4 elements sum is equal to target, store them. Else according to sum, move left and right pointers as elements are already sorted</p> <pre><code>class Solution:\n    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:\n        res = []\n        n = len(nums)\n        nums.sort()\n        for i in range(n):\n            if i != 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n):\n                if j != i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                required_sum = target - nums[i] - nums[j]\n                while left &lt; right:\n                    if nums[left] + nums[right] &lt; required_sum:\n                        left += 1\n                    elif nums[left] + nums[right] &gt; required_sum:\n                        right -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        left += 1\n                        right -= 1\n                        while left &lt; right and nums[left] == nums[left - 1]:\n                            left += 1\n                        while left &lt; right and nums[right] == nums[right + 1]:\n                            right -= 1\n\n        return res\n</code></pre> <p>(Another approach to avoid duplicates is storing them in set)</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:\n        res = set()\n        n = len(nums)\n        nums.sort()\n        for i in range(n):\n            for j in range(i + 1, n):\n                left, right = j + 1, n - 1\n                required_sum = target - nums[i] - nums[j]\n                while left &lt; right:\n                    if nums[left] + nums[right] &lt; required_sum:\n                        left += 1\n                    elif nums[left] + nums[right] &gt; required_sum:\n                        right -= 1\n                    else:\n                        res.add((nums[i], nums[j], nums[left], nums[right]))\n                        left += 1\n                        right -= 1\n</code></pre> <pre><code>use std::collections::HashSet;\n\nimpl Solution {\n    pub fn four_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let mut nums = nums;\n        nums.sort();\n        let n = nums.len();\n        let mut res: HashSet&lt;(i32, i32, i32, i32)&gt; = HashSet::new();\n\n        for i in 0..n {\n            for j in i + 1..n {\n                let (mut l, mut r) = (j + 1, n - 1);\n                let req = target as i64 - nums[i] as i64 - nums[j] as i64;\n                while l &lt; r {\n                    if (nums[l] + nums[r]) as i64 == req {\n                        res.insert((nums[i], nums[j], nums[l], nums[r]));\n                        l += 1;\n                        r -= 1;\n                    } else if ((nums[l] + nums[r]) as i64) &lt; req {\n                        l += 1;\n                    } else {\n                        r -= 1;\n                    }\n                }\n            }\n        }\n\n        let mut return_value: Vec&lt;Vec&lt;i32&gt;&gt; = vec![];\n        for (a, b, c, d) in res {\n            return_value.push(vec![a, b, c, d]);\n        }\n        return_value\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays4/#longest-consecutive-sequence","title":"Longest Consecutive Sequence","text":"<p>\u2753: You are given an array of \u2018N\u2019 integers. You need to find the length of the longest sequence which contains the consecutive elements. \ud83e\udde0: O(NlogN) Solution 1. Sort the array 2. Find the consecutive sequence by iterating through array. (it cannot have same elements)</p> <p>O(N) Solution 1. Store all the elements in set 2. For every element, search and count all the consecutive elements only if     a. It is start of sequence(curr-1 is not in set)     b. We will storing maximum sequence in a variable res. if curr + res is not present in set, that means the curr count itself is large sequence, again don't need to find the current sequence length</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:\n        nums.sort()\n        n = len(nums)\n        if n &lt;= 1:\n            return n\n\n        res = 1\n        curr_count = 1\n\n        prev = nums[0]\n        for num in nums[1:]:\n            if prev + 1 == num:\n                curr_count += 1\n                prev = num\n            elif num == prev:\n                continue\n            else:\n                prev = num\n                res = max(res, curr_count)\n                curr_count = 1\n\n        return max(res, curr_count)\n\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:\n        res = 0\n        temp = {i: 1 for i in nums}\n        for i in nums:\n            if i - 1 in temp or i + res not in temp:\n                continue\n            c = 1\n            e = i\n            while e + 1 in temp:\n                c += 1\n                e += 1\n            res = max(res, c)\n        return res\n</code></pre> <pre><code>use std::cmp::max;\n\nimpl Solution {\n    pub fn longest_consecutive(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        let mut nums = nums;\n        nums.sort();\n        let n = nums.len();\n        if n == 0 {\n            return 0;\n        }\n        let mut prev = nums[0];\n        let mut count = 1;\n        let mut res = 1;\n\n        for &amp;num in &amp;nums[1..] {\n            if num == prev {\n                continue;\n            } else if num == prev + 1 {\n                count += 1;\n            } else {\n                res = max(res, count);\n                count = 1;\n            }\n            prev = num;\n        }\n\n        max(res, count)\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"arrays/arrays4/#longest-subarray-with-zero-sum","title":"Longest SubArray with Zero Sum","text":"<p>\u2753: Given an array containing both positive and negative integers, we have to find the length of the longest subarray with the sum of all elements equal to zero. \ud83e\udde0: 1. Store the prefix sum in hashmap with value as index 2. if we find the prefix sum again, then that part of array sum is zero</p> \ud83d\udc0d\ud83e\udd80 <pre><code>def solution(nums: list[int]) -&gt; int:\n    d: dict[int, int] = {0: -1}\n    curr_sum = 0\n    res = 0\n    for i, num in enumerate(nums):\n        curr_sum += num\n        if curr_sum in d:\n            res = max(res, i - d[curr_sum])\n        else:\n            d[curr_sum] = i\n    return res\n\n\nassert solution([9, -3, 3, -1, 6, -5]) == 5\nassert solution([6, -2, 2, -8, 1, 7, 4, -10]) == 8\nassert solution([1, 0, -5]) == 1\nassert solution([1, 3, -5, 6, -2]) == 0\n</code></pre> <pre><code>use std::cmp::max;\nuse std::collections::HashMap;\n\nfn longest_subarray_with_zero_sum(nums: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    let mut d: HashMap&lt;i32, i32&gt; = HashMap::new();\n    d.insert(0, -1);\n    let mut sum = 0;\n    let mut res = 0;\n\n    for i in 0..nums.len() {\n        sum += nums[i];\n        if d.contains_key(&amp;sum) {\n            res = max(res, i as i32 - d[&amp;sum])\n        } else {\n            d.insert(sum, i as i32);\n        }\n    }\n    res\n}\n\nfn main() {\n    assert_eq!(\n        longest_subarray_with_zero_sum(&amp;vec![9, -3, 3, -1, 6, -5]),\n        5\n    );\n    assert_eq!(\n        longest_subarray_with_zero_sum(&amp;vec![6, -2, 2, -8, 1, 7, 4, -10]),\n        8\n    );\n    assert_eq!(longest_subarray_with_zero_sum(&amp;vec![1, 0, -5]), 1);\n    assert_eq!(longest_subarray_with_zero_sum(&amp;vec![1, 3, -5, 6, -2]), 0);\n}\n</code></pre> <p>\ud83d\udcd8</p>"},{"location":"arrays/arrays4/#count-number-of-subarrays-with-given-xor-k","title":"Count number of subarrays with given XOR K","text":"<p>Coming Soon</p>"},{"location":"arrays/arrays4/#longest-substring-without-repeating-characters","title":"Longest Substring without repeating characters","text":"<p>\u2753: Given a String, find the length of longest substring without any repeating character. \ud83e\udde0: 1. Store the seen elements in hashmap with its indexes 2. Once you encounter a seen element, compute the res by finding the gap b/w current index and seen index and reset left pointer to seen index plus 1</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        n = len(s)\n        if s == \"\":\n            return 0\n        left = 0\n        seen = {}\n        res = 0\n        for i in range(n):\n            if s[i] in seen and seen[s[i]] &gt;= left:\n                res = max(res, i - left)\n                left = seen[s[i]] + 1\n            seen[s[i]] = i\n\n        return max(res, i - left + 1)\n</code></pre> <pre><code>use std::cmp::max;\nuse std::collections::HashMap;\n\nimpl Solution {\n    pub fn length_of_longest_substring(s: String) -&gt; i32 {\n        let n = s.len();\n        if n == 0 {\n            return 0;\n        }\n        let mut seen: HashMap&lt;char, usize&gt; = HashMap::new();\n        let mut left = 0;\n        let mut res = 0;\n\n        for (i, ch) in s.chars().enumerate() {\n            if seen.contains_key(&amp;ch) &amp;&amp; seen[&amp;ch] &gt;= left {\n                res = max(res, i - left);\n                left = seen[&amp;ch] + 1;\n            }\n            seen.insert(ch, i);\n        }\n\n        max(res, n - left) as i32\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_search/bs/","title":"Binary Search","text":""},{"location":"binary_search/bs/#nth-root-of-an-integer","title":"Nth root of an integer","text":"<p>\u2753: You are given two positive integers 'n' and 'm'. You have to return the 'nth' root of 'm', i.e. 'm(1/n)'. If the 'nth root is not an integer, return -1. </p> <p>Example: 3 27</p> <p>Output: 3</p> <p>Explanation For Sample Input 1: 3rd Root of 27 is 3, as (3)^3 equals 27.</p> \ud83d\udc0d\ud83e\udd80 <pre><code>def NthRoot(n: int, m: int) -&gt; int:\n    low, high = 0, m\n\n    while low &lt;= high:\n        mid = (low + high) // 2\n\n        curr = mid**n\n\n        if curr == m:\n            return mid\n        elif curr &lt; m:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n</code></pre> <pre><code>fn nth_root(n: i32, m: i32) -&gt; i32 {\n    let (mut low, mut high) = (0, m);\n\n    while low &lt;= high {\n        let mid = (low + high) / 2;\n        let curr = mid.pow(n as u32);\n\n        if curr == m {\n            return mid;\n        } else if curr &lt; m {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    -1\n}\n\nfn main() {\n    assert_eq!(nth_root(3, 27), 3);\n    assert_eq!(nth_root(4, 69), -1);\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_search/bs/#matrix-median","title":"Matrix Median","text":"<p>Coming Soon</p>"},{"location":"binary_search/bs/#single-element-in-a-sorted-array","title":"Single Element in a Sorted Array","text":"<p>\u2753: You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</p> <p>Return the single element that appears only once.</p> <p>Example: Input: nums = [1,1,2,3,3,4,4,8,8] Output: 2</p> <p>\ud83e\udde0: Elements which are repeated twice will be at  1. odd, even indices to left of target 2. even, odd indices to right of target</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -&gt; int:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if nums[0] != nums[1]:\n            return nums[0]\n        if nums[-1] != nums[-2]:\n            return nums[-1]\n\n        low, high = 1, n - 2\n\n        while low &lt;= high:\n            mid = (low + high) // 2\n\n            if nums[mid - 1] != nums[mid] != nums[mid + 1]:\n                return nums[mid]\n\n            elif nums[mid] == nums[mid - 1]:\n                if mid % 2:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            else:\n                if mid % 2:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n</code></pre> <pre><code>impl Solution {\n    pub fn single_non_duplicate(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        let n = nums.len();\n\n        if n == 1 || nums[0] != nums[1] {\n            return nums[0];\n        }\n        if nums[n - 1] != nums[n - 2] {\n            return nums[n - 1];\n        }\n\n        let (mut low, mut high) = (1, n - 2);\n\n        while low &lt;= high {\n            let mid = (low + high) / 2;\n\n            if nums[mid] != nums[mid - 1] &amp;&amp; nums[mid] != nums[mid + 1] {\n                return nums[mid];\n            } else if nums[mid] != nums[mid - 1] {\n                if mid % 2 == 1 {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            } else {\n                if mid % 2 == 1 {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n        }\n\n        1\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_search/bs/#search-in-rotated-sorted-array","title":"Search in Rotated Sorted Array","text":"<p>\u2753: There is an integer array nums sorted in ascending order (with distinct values).</p> <p>Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].</p> <p>Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</p> <p>Example: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4</p> <p>\ud83e\udde0: 1. On doing binary search, atleast one of left or right half will be sorted. 2. Eliminate one of them using that property.</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        n = len(nums)\n        low, high = 0, n - 1\n\n        while low &lt;= high:\n            mid = (low + high) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            elif nums[low] &lt;= nums[mid]:\n                if nums[low] &lt;= target &lt; nums[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n\n            else:\n                if nums[mid] &lt; target &lt;= nums[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n\n        return -1\n</code></pre> <pre><code>impl Solution {\n    pub fn search(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 {\n        let n = nums.len();\n\n        let (mut low, mut high) = (0, n - 1);\n\n        while low &lt;= high {\n            let mid = (low + high) / 2;\n\n            if nums[mid] == target {\n                return mid as i32;\n            } else if nums[low] &lt;= nums[mid] {\n                if nums[low] &lt;= target &amp;&amp; target &lt; nums[mid] {\n                    high = mid - 1\n                } else {\n                    low = mid + 1\n                }\n            } else {\n                if nums[mid] &lt; target &amp;&amp; target &lt;= nums[high] {\n                    low = mid + 1\n                } else {\n                    high = mid - 1\n                }\n            }\n        }\n\n        -1\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_search/bs/#median-of-2-sorted-arrays","title":"Median of 2 Sorted Arrays","text":"<p>Coming Soon</p>"},{"location":"binary_search/bs/#kth-element-of-2-sorted-arrays","title":"Kth Element of 2 Sorted Arrays","text":"<p>Coming Soon</p>"},{"location":"binary_search/bs/#allocate-minimum-number-of-pages","title":"Allocate Minimum Number of Pages","text":"<p>Coming Soon</p>"},{"location":"binary_search/bs/#agressive-cows","title":"Agressive Cows","text":"<p>\u2753: Given an array nums of size n, which denotes the positions of stalls, and an integer k, which denotes the number of aggressive cows, assign stalls to k cows such that the minimum distance between any two cows is the maximum possible. Find the maximum possible minimum distance.    </p> <p>Example: Input: n = 6, k = 4, nums = [0, 3, 4, 7, 10, 9]</p> <p>Output: 3</p> <p>Explanation: The maximum possible minimum distance between any two cows will be 3 when 4 cows are placed at positions [0, 3, 7, 10]. Here the distances between cows are 3, 4, and 3 respectively. We cannot make the minimum distance greater than 3 in any ways.  </p> <p>\ud83e\udde0: 1. Minimum possible way is 1 and maximum is max(arr) - min(arr). 2. Linear search approach would be trying all the values in range till we find maximum result. 3. Binary search approach is going to mid element and check whether it is possible or not. 4. If it is possible, as we need max value, eliminate left half to find better answer in right half. 5. Else, eliminate right half to find answer in left half.</p> <pre><code>class Solution:\n    def aggressiveCows(self, nums, k):\n        self.nums = sorted(nums)\n        self.k = k\n        self.n = len(nums)\n        self.res = 0\n        self.helper()\n        return self.res\n\n    def helper(self):\n        low, high = 0, self.nums[-1] - self.nums[0]\n\n        while low &lt;= high:\n            mid = (low + high) // 2\n\n            if self._is_possible(mid):\n                self.res = max(self.res, mid)\n                low = mid + 1\n            else:\n                high = mid - 1\n\n    def _is_possible(self, d):\n        prev = 0\n        count = self.k - 1\n\n        for i in range(1, self.n):\n            if self.nums[i] - self.nums[prev] &gt;= d:\n                prev = i\n                count -= 1\n\n            if not count:\n                return True\n\n        return not count\n</code></pre> <p>\ud83d\udcd8 </p>"},{"location":"binary_search_trees/bst/","title":"Part1","text":""},{"location":"binary_search_trees/bst/#populate-next-right-pointers-of-tree","title":"Populate Next Right pointers of Tree","text":"<p>\u2753: You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p> <p>struct Node {   int val;   Node *left;   Node *right;   Node *next; }</p> <p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p> <p>Initially, all next pointers are set to NULL. </p> <p>Example:  </p> <p> Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#]  </p> <p>\ud83e\udde0: At each level, for every node, perform 2 steps     a. make left next to right     b. If node has any next, make right next as next left</p> <pre><code>class Solution:\n    def connect(self, root: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n        curr_level_head = root\n\n        while curr_level_head and curr_level_head.left:\n            temp = curr_level_head\n\n            while temp:\n                temp.left.next = temp.right\n                if temp.next:\n                    temp.right.next = temp.next.left\n                temp = temp.next\n\n            curr_level_head = curr_level_head.left\n\n        return root\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst/#construct-bst-from-given-keys","title":"Construct BST from given keys","text":"<pre><code>class Solution:\n    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:\n        n = len(nums)\n\n        if n == 0:\n            return\n        if n == 1:\n            return TreeNode(nums[0])\n\n        mid = n // 2\n\n        node = TreeNode(nums[mid])\n        node.left = self.sortedArrayToBST(nums[:mid])\n        node.right = self.sortedArrayToBST(nums[mid + 1 :])\n        return node\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst/#construct-a-bst-from-a-preorder-traversal","title":"Construct a BST from a preorder traversal","text":"<p>\ud83e\udde0: 1. For BST, inorder will be sorted. 2. Find inorder by sorting preorder and construct BT.  </p> <pre><code>class Solution:\n    def bstFromPreorder(self, preorder: List[int]) -&gt; Optional[TreeNode]:\n        return self.buildTree(preorder, sorted(preorder))\n\n    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n        if not preorder:\n            return\n\n        root_val = preorder.pop(0)\n        node = TreeNode(root_val)\n\n        root_inorder_ind = inorder.index(root_val)\n\n        node.left = self.buildTree(\n            preorder[:root_inorder_ind], inorder[:root_inorder_ind]\n        )\n        node.right = self.buildTree(\n            preorder[root_inorder_ind:], inorder[root_inorder_ind + 1 :]\n        )\n\n        return node\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst/#check-is-a-bt-is-bst-or-not","title":"Check is a BT is BST or not","text":"<pre><code>class Solution:\n    def isValidBST(\n        self, root: Optional[TreeNode], mini=float(\"-inf\"), maxi=float(\"inf\")\n    ) -&gt; bool:\n        if not root:\n            return True\n\n        if not (mini &lt; root.val &lt; maxi):\n            return False\n\n        return self.isValidBST(root.left, mini, root.val) and self.isValidBST(\n            root.right, root.val, maxi\n        )\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst/#find-lca-of-two-nodes-in-bst","title":"Find LCA of two nodes in BST","text":"<pre><code>class Solution:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -&gt; \"TreeNode\":\n        curr = root\n\n        while curr:\n            if curr.val &lt; p.val and curr.val &lt; q.val:\n                curr = curr.right\n\n            elif curr.val &gt; p.val and curr.val &gt; q.val:\n                curr = curr.left\n\n            else:\n                return curr\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst/#find-the-inorder-predecessorsuccessor-of-a-given-key-in-bst","title":"Find the inorder predecessor/successor of a given Key in BST","text":"<p>\u2753: You are given root node of the BST and the key node of the tree. You need to find the in-order successor and predecessor of a given key. If either predecessor or successor is not found, then set it to NULL.</p> <p>Note:- In an inorder traversal the number just smaller than the target is the predecessor and the number just greater than the target is the successor. </p> <p>Example: <pre><code>      8\n    /   \\\n   1     9\n   \\      \\\n    4      10\n   /\n  3\n</code></pre> key = 8 Output: 4 9  </p> <pre><code>class Solution:\n    def succPredBST(self, root, key):\n        pred = succ = -1\n\n        self.key = key\n\n        curr = root\n\n        while curr:\n            if curr.data &lt; key:\n                pred = curr.data\n                curr = curr.right\n            else:\n                curr = curr.left\n\n        curr = root\n        while curr:\n            if curr.data &gt; key:\n                succ = curr.data\n                curr = curr.left\n            else:\n                curr = curr.right\n\n        return pred, succ\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst_ii/","title":"Part2","text":""},{"location":"binary_search_trees/bst_ii/#floor-in-a-bst","title":"Floor in a BST","text":"<pre><code>class Solution:\n    def floor(self, root, X):\n        node = root\n        res = -1\n\n        while node:\n            if node.data == X:\n                return node.data\n            elif node.data &lt; X:\n                res = max(res, node.data)\n                node = node.right\n            else:\n                node = node.left\n\n        return res\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst_ii/#ceil-in-a-bst","title":"Ceil in a BST","text":"<pre><code>class Solution:\n    def findCeil(self, root, X):\n        res = float(\"inf\")\n        node = root\n\n        while node:\n            if node.key == X:\n                return node.key\n\n            elif node.key &gt; X:\n                res = min(res, node.key)\n                node = node.left\n\n            else:\n                node = node.right\n\n        return res if res != float(\"inf\") else -1\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst_ii/#find-k-th-smallest-element-in-bst","title":"Find K-th smallest element in BST","text":"<p>Example:  </p> <p> </p> <p>Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3  </p> <pre><code>class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:\n        self.k = k\n        self.res = None\n        self.inorder(root)\n        return self.res\n\n    def inorder(self, node):\n        if not node:\n            return\n\n        self.inorder(node.left)\n        self.k -= 1\n        if not self.k:\n            self.res = node.val\n            return\n        self.inorder(node.right)\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst_ii/#find-k-th-largest-element-in-bst","title":"Find K-th largest element in BST","text":"<pre><code>class Solution:\n    def kthLargest(self, root, k):\n        self.k = k\n        self.res = None\n        self.inorder(root)\n        return self.res\n\n    def inorder(self, node):\n        if not node:\n            return\n\n        self.inorder(node.right)\n        self.k -= 1\n        if not self.k:\n            self.res = node.data\n            return\n        self.inorder(node.left)\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst_ii/#find-a-pair-with-a-given-sum-in-bst","title":"Find a pair with a given sum in BST","text":"<pre><code>class Solution:\n    def findTarget(self, root: Optional[TreeNode], k: int) -&gt; bool:\n        self.k = k\n        return self.helper(root, set())\n\n    def helper(self, node, seen):\n        if not node:\n            return False\n\n        if self.k - node.val in seen:\n            return True\n\n        seen.add(node.val)\n        return self.helper(node.left, seen) or self.helper(node.right, seen)\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_search_trees/bst_ii/#bst-iterator","title":"BST iterator","text":"<p>Refer leetcode link for problem description</p> <pre><code>class BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.inorder_arr = []\n        self._inorder(root)\n        self.curr_ind = -1\n\n    def next(self) -&gt; int:\n        self.curr_ind += 1\n        return self.inorder_arr[self.curr_ind]\n\n    def hasNext(self) -&gt; bool:\n        return (self.curr_ind + 1) &lt; len(self.inorder_arr)\n\n    def _inorder(self, node):\n        if not node:\n            return\n        self._inorder(node.left)\n        self.inorder_arr.append(node.val)\n        self._inorder(node.right)\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees/","title":"Part1","text":""},{"location":"binary_trees/binary_trees/#inorder-traversal","title":"Inorder Traversal","text":"<pre><code>class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:\n        self.res = []\n        self.inorder(root)\n        return self.res\n\n    def inorder(self, node):\n        if not node:\n            return\n        self.inorder(node.left)\n        self.res.append(node.val)\n        self.inorder(node.right)\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees/#preorder-traversal","title":"Preorder Traversal","text":"<pre><code>class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:\n        self.res = []\n        self.preorder(root)\n        return self.res\n\n    def preorder(self, node):\n        if not node:\n            return\n\n        self.res.append(node.val)\n        self.preorder(node.left)\n        self.preorder(node.right)\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees/#postorder-traversal","title":"Postorder Traversal","text":"<pre><code>class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:\n        self.res = []\n        self.postorder(root)\n        return self.res\n\n    def postorder(self, node):\n        if not node:\n            return\n\n        self.postorder(node.left)\n        self.postorder(node.right)\n        self.res.append(node.val)\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees/#leftview-of-binary-tree","title":"LeftView Of Binary Tree","text":"<p>Example: Input: root[] = [1, 2, 3, 4, 5, N, N]</p> <p></p> <p>Output: [1, 2, 4]</p> <p>Explanation: From the left side of the tree, only the nodes 1, 2, and 4 are visible.</p> <p>\ud83e\udde0: Use BFS, result is list of first element in each level of binary tree.</p> <pre><code>class Solution:\n    def LeftView(self, root):\n        res = []\n\n        if not root:\n            return res\n\n        queue = [root]\n\n        while queue:\n            res.append(queue[0].data)\n\n            for _ in range(len(queue)):\n                curr = queue.pop(0)\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n\n        return res\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees/#bottom-view-of-binary-tree","title":"Bottom View of Binary Tree","text":"<p>Example: </p> <p>For the above tree, the output should be 4 2 5 3.</p> <p>\ud83e\udde0: 1. Use BFS, carry level during traversal, on going left decrease the level, on going right increase the level. 2. Result is list of last elements in each level.  </p> <pre><code>class Solution:\n    def bottomView(self, root):\n        if not root:\n            return []\n\n        view = {}\n        queue = [(root, 0)]\n\n        while queue:\n            node, level = queue.pop(0)\n\n            view[level] = node.data\n\n            if node.left:\n                queue.append((node.left, level - 1))\n            if node.right:\n                queue.append((node.right, level + 1))\n\n        return [view[key] for key in sorted(view)]\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees/#top-view-of-binary-tree","title":"Top View of Binary Tree","text":"<p>\ud83e\udde0: Same as bottom view, result is list of first elements in each level. </p> <pre><code>class Solution:\n    def topView(self, root):\n        if not root:\n            return []\n\n        view = {}\n        queue = [(root, 0)]\n\n        while queue:\n            node, level = queue.pop(0)\n\n            if level not in view:\n                view[level] = node.data\n\n            if node.left:\n                queue.append((node.left, level - 1))\n            if node.right:\n                queue.append((node.right, level + 1))\n\n        return [view[key] for key in sorted(view)]\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees/#vertical-order-traversal","title":"Vertical order traversal","text":"<p>\u2753: The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.  </p> <p>Example: </p> <p>Input: root = [1,2,3,4,5,6,7] Output: [[4],[2],[1,5,6],[3],[7]]</p> <p>\ud83e\udde0: 1. Use BFS, use level logic, on going left decrease the level, on going right increase the level. 2. During BFS, we will be iterating for each height. 3. If multiple elements found in the same level and also at the same height, sort them.  </p> <pre><code>from collections import defaultdict\n\n\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n        if not root:\n            return []\n\n        view = defaultdict(list)\n        queue = [(root, 0)]\n\n        while queue:\n            curr_view = defaultdict(list)\n\n            for _ in range(len(queue)):\n                node, level = queue.pop(0)\n                curr_view[level].append(node.val)\n\n                if node.left:\n                    queue.append((node.left, level - 1))\n                if node.right:\n                    queue.append((node.right, level + 1))\n\n            for level in curr_view:\n                if level in view:\n                    view[level].extend(sorted(curr_view[level]))\n                else:\n                    view[level] = sorted(curr_view[level])\n\n        return [view[key] for key in sorted(view)]\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees/#root-to-leaf-paths","title":"Root to Leaf Paths","text":"<p>\u2753: Given a Binary Tree, you need to find all the possible paths from the root node to all the leaf nodes of the binary tree.</p> <p>Example:  </p> <p>Input: root[] = [1, 2, 3, 4, 5]</p> <p></p> <p>Output: [[1, 2, 4], [1, 2, 5], [1, 3]]  Explanation: All possible paths: 1-&gt;2-&gt;4, 1-&gt;2-&gt;5 and 1-&gt;3</p> <p>\ud83e\udde0: Use DFS</p> <pre><code>class Solution:\n    def Paths(self, root):\n        self.res = []\n        self.helper(root)\n        return self.res\n\n    def helper(self, node, curr=[]):\n        if node.left is None and node.right is None:\n            curr.append(node.data)\n            self.res.append(curr[:])\n            curr.pop()\n            return\n\n        curr.append(node.data)\n        if node.left:\n            self.helper(node.left)\n        if node.right:\n            self.helper(node.right)\n        curr.pop()\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees/#max-width-of-a-binary-tree","title":"Max width of a Binary Tree","text":"<p>\u2753: Given a Binary Tree, return its maximum width. The maximum width of a Binary Tree is the maximum diameter among all its levels. The width or diameter of a level is the number of nodes between the leftmost and rightmost nodes.</p> <p>Example:  </p> <p></p> <p>Input: root = [1,3,2,5,null,null,9,6,null,7] Output: 7 Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).</p> <p>\ud83e\udde0: 1. Use BFS, use index for every element while traversal. 2. If i is index of a node, its left child index is 2i, right child index is 2i + 1. 3. Find width at each level of BFS.  </p> <pre><code>class Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        res = 0\n\n        queue = [(root, 0)]\n\n        while queue:\n            res = max(res, queue[-1][-1] - queue[0][-1] + 1)\n\n            for _ in range(len(queue)):\n                node, index = queue.pop(0)\n\n                if node.left:\n                    queue.append((node.left, 2 * index))\n                if node.right:\n                    queue.append((node.right, 2 * index + 1))\n\n        return res\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_2/","title":"Part2","text":""},{"location":"binary_trees/binary_trees_2/#level-order-traversal","title":"Level order Traversal","text":"<p>Example:  </p> <p></p> <p>Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]]  </p> <p>\ud83e\udde0: BFS</p> <pre><code>class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n        res = []\n        if not root:\n            return res\n\n        queue = [root]\n        while queue:\n            curr = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                curr.append(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            res.append(curr)\n        return res\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_2/#height-of-binary-tree","title":"Height of Binary Tree","text":"<p>Example:  </p> <p> Input: root = [3,9,20,null,null,15,7] Output: 3</p> <pre><code>class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_2/#diamter-of-binary-tree","title":"Diamter of Binary Tree","text":"<p>Example:  </p> <p> Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].</p> <pre><code>class Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.res = 0\n        self.helper(root)\n        return self.res\n\n    def helper(self, node):\n        if not node:\n            return 0\n\n        lh = self.helper(node.left)\n        rh = self.helper(node.right)\n\n        self.res = max(self.res, lh + rh)\n\n        return 1 + max(lh, rh)\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_2/#balanced-binary-tree","title":"Balanced Binary Tree","text":"<p>\u2753: Given a binary tree, determine if it is height-balanced</p> <p>A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p> <pre><code>class Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -&gt; bool:\n        self.res = True\n        self.helper(root)\n        return self.res\n\n    def helper(self, node):\n        if not node:\n            return 0\n\n        lh = self.helper(node.left)\n        rh = self.helper(node.right)\n\n        if abs(lh - rh) &gt; 1:\n            self.res = False\n\n        return 1 + max(lh, rh)\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_2/#lca","title":"LCA","text":"<p>Example:  </p> <p>  Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3.</p> <p>\ud83e\udde0: 1. Return None or Node in every recusive call for both left and right childs. 2. If both left and right recursive calls is not None, then current node is your answer.  </p> <pre><code>class Solution:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -&gt; \"TreeNode\":\n        if not root or p is root or q is root:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        if None in (left, right):\n            return left or right\n\n        return root\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_2/#check-if-two-trees-are-identical-or-not","title":"Check if two trees are identical or not","text":"<pre><code>class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n        if p is None:\n            return q is None\n\n        if q is None:\n            return p is None\n\n        return (\n            p.val == q.val\n            and self.isSameTree(p.left, q.left)\n            and self.isSameTree(p.right, q.right)\n        )\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_2/#zigzag-level-order-traversal","title":"Zigzag Level Order Traversal","text":"<p>Example:  </p> <p> Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]]  </p> <p>\ud83e\udde0: 1. Use BFS 2. Use zig_zag flag at every level to zig zag the iteration.  </p> <pre><code>class Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n        res = []\n        if not root:\n            return res\n\n        queue = [root]\n        zig_zag = 1\n\n        while queue:\n            curr_level = []\n\n            for _ in range(len(queue)):\n                curr_node = queue.pop(0)\n\n                curr_level.append(curr_node.val)\n\n                if curr_node.left:\n                    queue.append(curr_node.left)\n                if curr_node.right:\n                    queue.append(curr_node.right)\n\n            res.append(curr_level[::zig_zag])\n            zig_zag *= -1\n\n        return res\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_2/#boundary-traversal","title":"Boundary Traversal","text":"<p>\u2753: Given a Binary Tree, perform the boundary traversal of the tree. The boundary traversal is the process of visiting the boundary nodes of the binary tree in the anticlockwise direction, starting from the root.</p> <p>Example:  </p> <p> Input:Binary Tree: 1 2 7 3 -1 -1 8 -1 4 9 -1 5 6 10 11 Output: Boundary Traversal: [1, 2, 3, 4, 5, 6, 10, 11, 9, 8, 7]  </p> <p>\ud83e\udde0: 1. Result is - root + left boundary excluding leaves + leaf nodes + reversed right boundary excluding leaves 2. Edge case - If root is leave node, return [root value]  </p> <pre><code>class Solution:\n    def traverseBoundary(self, root):\n        # edge case: if root is leaf node\n        if root.left is None and root.right is None:\n            return [root.data]\n\n        return (\n            [root.data]\n            + self.get_left_boundary(root.left)\n            + self.get_leaves(root)\n            + self.get_right_boundary(root.right)[::-1]\n        )\n\n    def get_left_boundary(self, node):\n        res = []\n\n        while node:\n            if not (node.left is None and node.right is None):\n                res.append(node.data)\n\n            if node.left:\n                node = node.left\n            else:\n                node = node.right\n\n        return res\n\n    def get_right_boundary(self, node):\n        res = []\n\n        while node:\n            if not (node.left is None and node.right is None):\n                res.append(node.data)\n\n            if node.right:\n                node = node.right\n            else:\n                node = node.left\n\n        return res\n\n    def get_leaves(self, node, leaves=[]):\n        if node.left is None and node.right is None:\n            leaves.append(node.data)\n\n        if node.left:\n            self.get_leaves(node.left)\n\n        if node.right:\n            self.get_leaves(node.right)\n\n        return leaves\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_3/","title":"Part3","text":""},{"location":"binary_trees/binary_trees_3/#maximum-path-sum","title":"Maximum path sum","text":"<p>\u2753: A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p> <p>The path sum of a path is the sum of the node's values in the path.</p> <p>Example:</p> <p> Input: root = [-10,9,20,null,null,15,7] Output: 42 Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.   </p> <pre><code>class Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -&gt; int:\n        self.res = root.val\n        self.helper(root)\n        return self.res\n\n    def helper(self, node):\n        if not node:\n            return 0\n\n        ls = max(0, self.helper(node.left))\n        rs = max(0, self.helper(node.right))\n\n        self.res = max(self.res, node.val + ls + rs)\n\n        return node.val + max(ls, rs)\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_3/#construct-binary-tree-from-inorder-and-preorder","title":"Construct Binary Tree from inorder and preorder","text":"<pre><code>class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n        if not preorder:\n            return\n\n        root_val = preorder.pop(0)\n        node = TreeNode(root_val)\n\n        root_inorder_ind = inorder.index(root_val)\n\n        node.left = self.buildTree(\n            preorder[:root_inorder_ind], inorder[:root_inorder_ind]\n        )\n        node.right = self.buildTree(\n            preorder[root_inorder_ind:], inorder[root_inorder_ind + 1 :]\n        )\n\n        return node\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_3/#construct-binary-tree-from-inorder-and-postorder","title":"Construct Binary Tree from Inorder and Postorder","text":"<pre><code>class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n        if not postorder:\n            return\n\n        root_val = postorder.pop()\n        node = TreeNode(root_val)\n\n        root_inorder_ind = inorder.index(root_val)\n\n        node.left = self.buildTree(\n            inorder[:root_inorder_ind], postorder[:root_inorder_ind]\n        )\n        node.right = self.buildTree(\n            inorder[root_inorder_ind + 1 :], postorder[root_inorder_ind:]\n        )\n\n        return node\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_3/#symmetric-binary-tree","title":"Symmetric Binary Tree","text":"<pre><code>class Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:\n        return self.helper(root.left, root.right)\n\n    def helper(self, left_node, right_node):\n        if left_node is None:\n            return right_node is None\n\n        if right_node is None:\n            return left_node is None\n\n        return (\n            left_node.val == right_node.val\n            and self.helper(left_node.left, right_node.right)\n            and self.helper(left_node.right, right_node.left)\n        )\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_3/#mirror-tree","title":"Mirror Tree","text":"<p>Given a Binary Tree, convert it into its mirror.  </p> <p></p> <pre><code>class Solution:\n    def mirror(self, root):\n        if not root:\n            return\n        root.left, root.right = root.right, root.left\n        self.mirror(root.left)\n        self.mirror(root.right)\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"binary_trees/binary_trees_3/#check-for-children-sum-property","title":"Check for Children Sum Property","text":"<p>\u2753: Given a binary tree having n nodes. Check whether all of its nodes have a value equal to the sum of their child nodes. Return 1 if all the nodes in the tree satisfy the given properties, else it returns 0. For every node, the data value must be equal to the sum of the data values in the left and right children. Consider the data value 0 for a NULL child. Also, leaves are considered to follow the property.</p> <p>Example: <pre><code>       35\n      /  \\\n     20   15\n    / \\   / \\\n   15  5 10  5\n</code></pre> Output: 1 Explanation: Here, every node is sum of its left and right child.  </p> <pre><code>class Solution:\n    def isSumProperty(self, root):\n        if not root:\n            return 1\n        if root.left is None and root.right is None:\n            return 1\n\n        left = root.left.data if root.left else 0\n        right = root.right.data if root.right else 0\n\n        return (\n            (1 if root.data == left + right else 0)\n            and self.isSumProperty(root.left)\n            and self.isSumProperty(root.right)\n        )\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"greedy/greedy/","title":"Greedy Algorithms","text":""},{"location":"greedy/greedy/#n-meetings-in-one-room","title":"N Meetings in one room","text":"<p>\u2753:  There is one meeting room in a firm. You are given two arrays, start and end each of size N.For an index \u2018i\u2019, start[i] denotes the starting time of the ith meeting while end[i]  will denote the ending time of the ith meeting. Find the maximum number of meetings that can be accommodated if only one meeting can happen in the room at a  particular time. Print the order in which these meetings will be performed. Example: Input:  N = 6  start = {1,3,0,5,8,5}  end = {2,4,5,7,9,9} Output: 1 2 4 5 \ud83e\udde0: 1. Sort the items according to end time 2. Keep track of last meeting end time 2. Iterate through items and check whether the meeting start time is greater than last meeting end time</p> <pre><code>class Solution:\n    def maximumMeetings(self, start, end):\n        start, end = zip(*sorted(zip(start, end), key=lambda x: x[1]))\n\n        res = 0\n        prev_end = float(\"-inf\")\n        for a, b in zip(start, end):\n            if a &gt; prev_end:\n                prev_end = b\n                res += 1\n        return res\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"greedy/greedy/#minimum-number-of-platforms-required-for-a-railway","title":"Minimum number of platforms required for a railway","text":"<p>\u2753: We are given two arrays that represent the arrival and departure times of trains that stop at the platform. We need to find the minimum number of platforms needed at the railway station so that no train has to wait. Example: Input:  N = 6 arr = {9:00, 9:45, 9:55, 11:00, 15:00, 18:00} dep = {9:20, 12:00, 11:30, 11:50, 19:00, 20:00} Output: 3 \ud83e\udde0: 1. Combine both arrival and departure and sort them. 2. Iterate through both of them, if any arrival increase the counter. 3. If any departure, decrease the counter.  </p> <pre><code># O(N+M) extra space for creating new array\n\n\nclass Solution:\n    def minimumPlatform(self, arr, dep):\n        times = [(a, 0) for a in arr]\n        times.extend([(a, 1) for a in dep])\n        times.sort()\n\n        cnt = 0\n        res = 0\n        for a, b in times:\n            if b:\n                cnt -= 1\n            else:\n                cnt += 1\n            res = max(res, cnt)\n        return res\n\n\n# No extra space used - 2 pointers approach\nclass Solution:\n    def minimumPlatform(self, arr, dep):\n        arr.sort()\n        dep.sort()\n\n        n, m = len(arr), len(dep)\n        i = j = cnt = res = 0\n\n        while i &lt; n and j &lt; m:\n            if arr[i] &lt;= dep[j]:\n                cnt += 1\n                i += 1\n            else:\n                cnt -= 1\n                j += 1\n            res = max(res, cnt)\n\n        return res\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"greedy/greedy/#job-sequencing-problem","title":"Job Sequencing Problem","text":"<p>\u2753: You are given a set of N jobs where each job comes with a deadline and profit. The profit can only be earned upon completing the job within its deadline. Find the number of jobs done and the maximum profit that can be obtained. Each job takes a single unit of time and only one job can be performed at a time. Example: Input:  N = 4, Jobs = {(1,4,20),(2,1,10),(3,1,40),(4,1,30)}  Output: 2 60 Explanation: The 3rd job with a deadline 1 is performed during the first unit of time .The 1st job is performed during the second unit of time as its deadline is 4. Profit = 40 + 20 = 60 \ud83e\udde0: 1. Sort the jobs pased on profit. 2. Try to complete the job as late as possible.</p> <pre><code>class Solution:\n    def JobSequencing(self, ids, deadline, profit):\n        ids, deadline, profit = zip(\n            *sorted(zip(ids, deadline, profit), key=lambda x: x[2], reverse=True)\n        )\n        cnt = total_profit = 0\n        jobs = [None] * (max(deadline) + 1)\n\n        for _, a, b in zip(ids, deadline, profit):\n            for day in range(a, 0, -1):\n                if not jobs[day]:\n                    jobs[day] = b\n                    cnt += 1\n                    total_profit += b\n                    break\n\n        return cnt, total_profit\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"greedy/greedy/#fractional-knapsack-problem-greedy-approach","title":"Fractional Knapsack Problem : Greedy Approach","text":"<p>\u2753: The weight of N items and their corresponding values are given. We have to put these items in a knapsack of weight W such that the total value obtained is maximized. Note: We can either take the item as a whole or break it into smaller units.   Example: Input:  N = 3, W = 50, values[] = {100,60,120}, weight[] = {20,10,30}. Output: 240.00 Explanation: The first and second items  are taken as a whole  while only 20 units of the third item is taken. Total value = 100 + 60 + 80 = 240.00 \ud83e\udde0: 1. Sort the items according to value(Profit per unit weight). 2. At the end, when item weight is greater than remaining weight, take the fraction of it and return.  </p> <pre><code>class Solution:\n    def fractionalknapsack(self, val, wt, capacity):\n        val, wt = zip(*sorted(zip(val, wt), key=lambda x: x[0] / x[1], reverse=True))\n        res = 0\n\n        for a, b in zip(val, wt):\n            if b &lt;= capacity:\n                res += a\n                capacity -= b\n            else:\n                res += (a / b) * capacity\n                break\n        return res\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"greedy/greedy/#find-minimum-number-of-coins","title":"Find minimum number of coins","text":"<p>\u2753: Given a value V, if we want to make a change for V Rs, and we have an infinite supply of each of the denominations in Indian currency, i.e., we have an infinite supply of { 1, 2, 5, 10, 20, 50, 100, 500, 1000} valued coins/notes, what is the minimum number of coins and/or notes needed to make the change.    Example: Input: V = 70 Output: 2 Explaination: We need a 50 Rs note and a 20 Rs note. \ud83e\udde0: Iterate through high value coins to low value coins and try to get as many high value coins as we can.    </p> <pre><code>class Solution:\n    def minCoins(self, V):\n        coins = [1000, 500, 100, 50, 20, 10, 5, 2, 1]\n        res = 0\n\n        for coin in coins:\n            while V and coin &lt;= V:\n                res += 1\n                V -= coin\n\n        return res\n</code></pre> <p>\ud83d\udcd8</p>"},{"location":"greedy/greedy/#assign-cookies","title":"Assign Cookies","text":"<p>\u2753: Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.  </p> <p>Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.    Example: Input: g = [1,2,3], s = [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.  \ud83e\udde0: Sort the items and try to satisfy the child with least size cookie possible.</p> <pre><code>class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -&gt; int:\n        g.sort()\n        s.sort()\n\n        i, j = 0, 0\n\n        while i &lt; len(g) and j &lt; len(s):\n            if g[i] &lt;= s[j]:\n                i += 1\n            j += 1\n\n        return i\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"linked_list/part1/","title":"Part1","text":""},{"location":"linked_list/part1/#reverse-a-linked-list","title":"Reverse a Linked List","text":"<p>\u2753: Given the head of a singly linked list, write a program to reverse the linked list, and return the head pointer to the reversed list.</p> <pre><code># iterative approach\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_pointer = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_pointer\n        return prev\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list/part1/#middle-of-a-linked-list","title":"Middle of a Linked List","text":"<p>\u2753: Given the head of a linked list of integers, determine the middle node of the linked list. However, if the linked list has an even number of nodes, return the second middle node. \ud83e\udde0: 1. Use slow and fast pointers where fast pointer moves 2 steps and slow pointers moves 1 step at a time 2. When fast pointer is at the end of linked list, slow pointer will be in the middle</p> <pre><code>class Solution:\n    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        slow = fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        if fast.next is None:\n            return slow\n        if fast.next.next is None:\n            return slow.next\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list/part1/#remove-nth-node-from-end","title":"Remove nth node from end","text":"<p>\u2753: Given a linked list and an integer N, the task is to delete the Nth node from the end of the linked list and print the updated linked list. \ud83e\udde0: 1. Use 2 pointers slow and fast. Move fast pointer first from head by n steps 2. Now move the slow pointer till fast pointer reaches end. 3. Now the slow pointer's next node needs to be removed 4. Handle the edge case in the start if fast pointer moves beyond linked list</p> <pre><code>class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n        fast = head\n        for _ in range(n):\n            fast = fast.next\n        if fast is None:\n            return head.next\n        slow = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n        slow.next = slow.next.next\n        return head\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list/part1/#add-2-numbers","title":"Add 2 Numbers","text":"<p>\u2753: Given the heads of two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. \ud83e\udde0: 1. Iterate through both linked lists by carrying current remainder 2. Create new node with the remainder and curr sum and return the final linked list</p> <pre><code>class Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -&gt; Optional[ListNode]:\n        res = curr = None\n        remainder = curr_sum = 0\n        while l1 or l2:\n            curr_sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + remainder\n            remainder = curr_sum // 10\n\n            new_node = ListNode(val=curr_sum % 10)\n\n            if curr is None:\n                res = new_node\n                curr = new_node\n            else:\n                curr.next = new_node\n                curr = curr.next\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        if remainder:\n            curr.next = ListNode(val=remainder)\n\n        return res\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list/part1/#delete-the-given-node","title":"Delete the given node","text":"<p>\u2753: Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list instead, you will be given access to the node to be deleted directly. It is guaranteed that the node to be deleted is not a tail node in the list. \ud83e\udde0: Replace the node value with next node value and make next node as next node's next</p> <pre><code>class Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        node.val = node.next.val\n        node.next = node.next.next\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list/part2/","title":"Part2","text":""},{"location":"linked_list/part2/#find-the-intersection-of-2-linked-lists","title":"Find the intersection of 2 linked lists","text":"<p>\u2753: Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. \ud83e\udde0: 1. First find the length difference between 2 linked lists 2. Use 2 pointers cur1, curr2 for 1st and 2nd linked lists respectively 3. If l1 &gt; l2, move curr1 by l1-l2 steps ahead, else do the opposite for curr2 4. Now, curr1 and curr2 are same distance apart from intersection, move them simultaneously to find the junction point</p> <pre><code>class Solution:\n    def getIntersectionNode(\n        self, headA: ListNode, headB: ListNode\n    ) -&gt; Optional[ListNode]:\n        l1 = self.get_length_of_linked_list(headA)\n        l2 = self.get_length_of_linked_list(headB)\n\n        curr1 = headA\n        curr2 = headB\n        if l1 &gt; l2:\n            for _ in range(l1 - l2):\n                curr1 = curr1.next\n        else:\n            for _ in range(l2 - l1):\n                curr2 = curr2.next\n        while curr1 and curr2:\n            if curr1 == curr2:\n                return curr1\n            curr1 = curr1.next\n            curr2 = curr2.next\n        return None\n\n    def get_length_of_linked_list(self, node: ListNode):\n        res = 0\n        while node:\n            res += 1\n            node = node.next\n        return res\n\n\n# TODO need to check optimal approach\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list/part2/#detect-a-cycle-in-linked-list","title":"Detect a cycle in Linked List","text":"<p>\ud83e\udde0: 1. Use slow and fast pointers where fast moves 2 steps at a time and slow moves 1 step at a time 2. If there is a cycle, they will meet each other</p> <pre><code>class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list/part2/#check-for-palindrome","title":"Check for Palindrome","text":"<p>\u2753: Check if the given Linked List is Palindrome</p> <p>\ud83e\udde0: 1. Use slow and fast pointers and find the mid of the linked list 2. Reverse the 2nd half of linked list 3. Now travese both nodes and check values are same or not</p> <pre><code>class Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        prev = None\n        curr = slow\n        while curr:\n            nextnode = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nextnode\n        curr1 = head\n        curr2 = prev\n        while curr2:\n            if curr1.val != curr2.val:\n                return False\n            curr1 = curr1.next\n            curr2 = curr2.next\n        return True\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list/part2/#starting-point-of-loop","title":"Starting Point of Loop","text":"<p>\u2753: Given the head of a linked list that may contain a cycle, return the starting point of that cycle. If there is no cycle in the linked list return null.</p> <p>\ud83e\udde0: 1. Use slow and fast pointers and and find whether loop is there or not 2. #TODO If yes, now the distance between required node, head and required node and slow is same(Didn't get the approach completely)</p> <pre><code>class Solution:\n    def detectCycle(self, head: ListNode) -&gt; ListNode:\n        if not head or not head.next:\n            return None\n        slow = fast = entry = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if fast == slow:\n                while slow != entry:\n                    slow = slow.next\n                    entry = entry.next\n                return entry\n        return None\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list_and_arrays/linked_list_and_arrays/","title":"Linked List and Arrays","text":""},{"location":"linked_list_and_arrays/linked_list_and_arrays/#rotate-a-linked-list","title":"Rotate a Linked List","text":"<p>\u2753: Rotate the list to the right by k places. \ud83e\udde0: 1. Find n % k where n is length of linked list, because that k is the correct value to rotate at the end 2. Use slow and fast pointers. Give fast pointer k steps ahead start. 3. Now move slow and fast pointer simultaneoulsy till fast pointer reaches end to find the kth point 4. Change the corresponding node next values</p> <pre><code>class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        n = 0\n        curr = head\n        while curr:\n            n += 1\n            curr = curr.next\n\n        k = (k % n) if n else 0\n        if k == 0:\n            return head\n\n        fast = head\n        for _ in range(k):\n            fast = fast.next\n        slow = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n        res = slow.next\n        fast.next = head\n        slow.next = None\n        return res\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list_and_arrays/linked_list_and_arrays/#3sum","title":"3Sum","text":"<p>\u2753: Given an array of N integers, your task is to find unique triplets that add up to give a sum of zero. In short, you need to return an array of all the unique triplets [arr[a], arr[b], arr[c]] such that i!=j, j!=k, k!=i, and their sum is equal to zero. Algorithm1 - Using HashMap: 1. Iterate through array. For every iteration, perform 2 sum using hashmap 2. Sort the array to avoid duplicates</p> <p>Algorithm2 - Using BinarySearch: 1. Sort the array 2. Iterate through array. For every iteration, perform binary search approach 3. Use left and right pointers. If sum is greater than zero, increase left else decrease right. 4. If sum is zero, add items to res</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:\n        res = set()\n        nums.sort()\n        n = len(nums)\n        for i in range(n):\n            seen = set()\n            for j in range(i + 1, n):\n                required_num = 0 - nums[i] - nums[j]\n                if required_num in seen:\n                    res.add((nums[i], nums[j], required_num))\n                seen.add(nums[j])\n        return res\n\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:\n        nums.sort()\n        res = set()\n        n = len(nums)\n        for i in range(n):\n            left, right = i + 1, n - 1\n            while left &lt; right:\n                curr_sum = nums[i] + nums[left] + nums[right]\n                if not curr_sum:\n                    res.add((nums[i], nums[left], nums[right]))\n                    left += 1\n                    right -= 1\n                elif curr_sum &gt; 0:\n                    right -= 1\n                else:\n                    left += 1\n        return res\n</code></pre> <pre><code>use std::collections::HashSet;\n\nimpl Solution {\n    pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let mut nums = nums;\n        let mut res: HashSet&lt;(i32, i32, i32)&gt; = HashSet::new();\n        nums.sort();\n        let n = nums.len();\n\n        for i in 0..n {\n            let (mut l, mut r) = (i + 1, n - 1);\n            while l &lt; r {\n                let curr = nums[i] + nums[l] + nums[r];\n                if curr == 0 {\n                    res.insert((nums[i], nums[l], nums[r]));\n                    l += 1;\n                    r -= 1;\n                } else if curr &gt; 0 {\n                    r -= 1;\n                } else {\n                    l += 1;\n                }\n            }\n        }\n\n        let mut return_value: Vec&lt;Vec&lt;i32&gt;&gt; = vec![];\n        for item in res {\n            return_value.push(vec![item.0, item.1, item.2]);\n        }\n        return_value\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list_and_arrays/linked_list_and_arrays/#trapping-rainwater","title":"Trapping Rainwater","text":"<p>\u2753: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p> <p>Example:  </p> <p></p> <p>Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]</p> <p>Output: 6</p> <p>Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</p> <p>\ud83e\udde0: At a particular index, amount of water that can be trapped is height - min(prefix_max_height, suffix_max_height)</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def trap(self, heights: List[int]) -&gt; int:\n        n = len(heights)\n\n        pre_max = []\n        suff_max = []\n\n        curr_pre_max = curr_suff_max = 0\n\n        for i in range(n):\n            curr_pre_max = max(curr_pre_max, heights[i])\n            pre_max.append(curr_pre_max)\n\n            curr_suff_max = max(curr_suff_max, heights[n - i - 1])\n            suff_max.insert(0, curr_suff_max)\n\n        res = 0\n        for a, b, c in zip(heights, pre_max, suff_max):\n            res += min(b, c) - a\n\n        return res\n</code></pre> <pre><code>use std::cmp::{max, min};\n\nimpl Solution {\n    pub fn trap(heights: Vec&lt;i32&gt;) -&gt; i32 {\n        let (mut pmax, mut smax) = (0, 0);\n        let mut pmax_vec: Vec&lt;i32&gt; = vec![];\n        let mut smax_vec: Vec&lt;i32&gt; = vec![];\n        let n = heights.len();\n\n        for (i, &amp;height) in heights.iter().enumerate() {\n            pmax = max(pmax, height);\n            pmax_vec.push(pmax);\n\n            smax = max(smax, heights[n - i - 1]);\n            smax_vec.push(smax);\n        }\n\n        let mut res = 0;\n        smax_vec.reverse();\n        for i in 0..n {\n            res += min(pmax_vec[i], smax_vec[i]) - heights[i];\n        }\n\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list_and_arrays/linked_list_and_arrays/#remove-duplicates-from-sorted-array","title":"Remove duplicates from sorted array","text":"<p>\u2753: Given an integer array sorted in non-decreasing order, remove the duplicates in place such that each unique element appears only once. The relative order of the elements should be kept the same. \ud83e\udde0: 1. Use a curr pointer. Till curr pointer elements are correct 2. Iterate through array and find whether current elements is same as previous. If not, put that value in curr pointer and increase curr pointer value 3. The required length is till curr</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def removeDuplicates(self, nums: List[int]) -&gt; int:\n        n = len(nums)\n        curr = 1\n        for i in range(1, n):\n            if nums[i] == nums[i - 1]:\n                continue\n            nums[curr] = nums[i]\n            curr += 1\n        return curr\n</code></pre> <pre><code>impl Solution {\n    pub fn remove_duplicates(nums: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n        let n = nums.len();\n        let mut curr = 1;\n\n        for i in 1..n {\n            if nums[i] == nums[i - 1] {\n                continue;\n            }\n            nums[curr] = nums[i];\n            curr += 1;\n        }\n        curr as i32\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"linked_list_and_arrays/linked_list_and_arrays/#max-consecutive-ones","title":"Max Consecutive Ones","text":"<p>\u2753: Given an array that contains only 1 and 0 return the count of maximum consecutive ones in the array. \ud83e\udde0: 1. Iterate through array, it element is 1, increment counter 2. Else, res is maximum of res and curr</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int:\n        res = curr = 0\n        for i, v in enumerate(nums):\n            if v == 1:\n                curr += 1\n            else:\n                res = max(res, curr)\n                curr = 0\n        return max(curr, res)\n</code></pre> <pre><code>use std::cmp::max;\n\nimpl Solution {\n    pub fn find_max_consecutive_ones(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        let (mut curr, mut res) = (0, 0);\n        for &amp;num in &amp;nums {\n            if num != 1 {\n                res = max(res, curr);\n                curr = 0;\n            } else {\n                curr += 1;\n            }\n        }\n        max(res, curr)\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/backtracking/","title":"Recusion and Backtracking","text":""},{"location":"recursion/backtracking/#print-all-permutations-of-a-stringarray","title":"Print All Permutations of a String/Array","text":"<p>\u2753: Print All Permutations of a String/Array  </p> <p>Example:  </p> <p>Input: arr = [1, 2, 3]</p> <p>Output:  [   [1, 2, 3],   [1, 3, 2],   [2, 1, 3],   [2, 3, 1],   [3, 1, 2],   [3, 2, 1] ]  </p> <p>\ud83e\udde0: 1. Keep track of seen elements. 2. At every index, try all possible.</p> <pre><code>class Solution:\n    def permute(self, nums: List[int]) -&gt; List[List[int]]:\n        self.nums = nums\n        self.n = len(nums)\n        self.res = []\n        self.helper()\n        return self.res\n\n    def helper(self, seen=set(), curr=[]):\n        if len(seen) == self.n:\n            self.res.append(curr[:])\n            return\n\n        for ind in range(self.n):\n            if ind not in seen:\n                seen.add(ind)\n                curr.append(self.nums[ind])\n                self.helper()\n                seen.remove(ind)\n                curr.pop()\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/backtracking/#n-queen-problem","title":"N Queen Problem","text":"<p>\u2753: The n-queens is the problem of placing n queens on n \u00d7 n chessboard such that no two queens can attack each other. Given an integer n, return all distinct solutions to the n -queens puzzle. Each solution contains a distinct boards configuration of the queen's placement, where \u2018Q\u2019 and \u2018.\u2019 indicate queen and empty space respectively.</p> <p>Example: Input: n = 4</p> <p>Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] </p> <p>\ud83e\udde0: 1. At every position, check whether it is a valid position or not. 2. If yes, repeat process until we reach end index. 3. If no, backtrack and repeat the process</p> <pre><code>class Solution:\n    def solveNQueens(self, n: int) -&gt; List[List[str]]:\n        self.res = []\n        self.n = n\n        board = [[\".\"] * n for _ in range(n)]\n        self.helper(board)\n        return self.res\n\n    def helper(self, board, ind=0):\n        if ind == self.n:\n            self.res.append([\"\".join(item) for item in board])\n            return\n\n        for i in range(self.n):\n            if self.is_valid(ind, i, board):\n                board[ind][i] = \"Q\"\n                self.helper(board, ind + 1)\n                board[ind][i] = \".\"\n\n    def is_valid(self, row, col, board) -&gt; bool:\n        # up\n        r = row - 1\n        while r &gt;= 0:\n            if board[r][col] == \"Q\":\n                return False\n            r -= 1\n\n        # left diagonal\n        r, c = row - 1, col - 1\n        while r &gt;= 0 and c &gt;= 0:\n            if board[r][c] == \"Q\":\n                return False\n            r -= 1\n            c -= 1\n\n        # up diagonal\n        r, c = row - 1, col + 1\n        while r &gt;= 0 and c &lt; self.n:\n            if board[r][c] == \"Q\":\n                return False\n            r -= 1\n            c += 1\n\n        return True\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/backtracking/#sudoku-solver","title":"Sudoku Solver","text":"<p>\u2753: Given a 9x9 incomplete sudoku, solve it such that it becomes valid sudoku.   </p> <p>Example: </p> <pre><code>class Solution:\n    def solveSudoku(self, board: List[List[str]]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        self.b = board\n        self.helper()\n\n    def helper(self):\n        for i in range(9):\n            for j in range(9):\n                if self.b[i][j] == \".\":\n                    for digit in \"123456789\":\n                        if self.is_valid(i, j, digit):\n                            self.b[i][j] = digit\n                            if self.helper():\n                                return True\n                            self.b[i][j] = \".\"\n                    return False\n\n        return True\n\n    def is_valid(self, row, col, digit):\n        for i in range(9):\n            for j in range(9):\n                if self.b[i][col] == digit or self.b[row][j] == digit:\n                    return False\n\n        grid_row, grid_col = (row // 3) * 3, (col // 3) * 3\n        for i in range(grid_row, grid_row + 3):\n            for j in range(grid_col, grid_col + 3):\n                if self.b[i][j] == digit:\n                    return False\n\n        return True\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/backtracking/#m-coloring-problem","title":"M Coloring Problem","text":"<p>\u2753: Given an undirected graph and a number m, determine if the graph can be colored with at most m colors such that no two adjacent vertices of the graph are colored with the same color.  </p> <p>Example:  </p> <p>Input:  N = 4 M = 3 E = 5</p> <p>Edges[] = {   (0, 1),   (1, 2),   (2, 3),   (3, 0),   (0, 2) }</p> <p>Output: 1</p> <p>\ud83e\udde0: 1. Form the graph as adjacency list. 2. For every node, try to color all the colors. 3. If able to color the node with particular color, store it and move to next node. 4. Once all nodes are colored, return True, else return False.  </p> <pre><code>from collections import defaultdict\n\n\nclass Solution:\n    def graphColoring(self, edges, m, n):\n        self.adj = defaultdict(list)\n\n        for edge in edges:\n            self.adj[edge[0]].append(edge[1])\n            self.adj[edge[1]].append(edge[0])\n\n        self.m = m\n        self.n = n\n        return self.helper()\n\n    def helper(self, curr_node=0, colored={}):\n        if curr_node == self.n:\n            return True\n\n        for color in range(self.m):\n            if self.is_valid(curr_node, colored, color):\n                colored[curr_node] = color\n                if self.helper(curr_node + 1):\n                    return True\n\n        return False\n\n    def is_valid(self, node, colored, color) -&gt; bool:\n        for adj_node in self.adj[node]:\n            if colored.get(adj_node) == color:\n                return False\n\n        return True\n</code></pre> <p>\ud83d\udcd8</p>"},{"location":"recursion/backtracking/#rat-in-a-maze","title":"Rat in a Maze","text":"<p>\u2753: Consider a rat placed at (0, 0) in a square matrix of order N * N. It has to reach the destination at (N - 1, N - 1). Find all possible paths that the rat can take to reach from source to destination. The directions in which the rat can move are 'U'(up), 'D'(down), 'L' (left), 'R' (right). Value 0 at a cell in the matrix represents that it is blocked and the rat cannot move to it while value 1 at a cell in the matrix represents that rat can travel through it.</p> <p>Note: In a path, no cell can be visited more than one time.</p> <p>Print the answer in lexicographical(sorted) order</p> <p>Example: Input: N = 4 m[][] = {{1, 0, 0, 0},         {1, 1, 0, 1},          {1, 1, 0, 0},         {0, 1, 1, 1}}</p> <p>Output: DDRDRR DRDDRR</p> <pre><code>class Solution:\n    def findPath(self, mat):\n        self.mat = mat\n        self.n = len(mat)\n        self.res = []\n        self.helper()\n        return sorted(self.res)\n\n    def helper(self, r=0, c=0, curr=\"\", seen=set()):\n        if not self.is_valid(r, c, seen):\n            return\n\n        if r == self.n - 1 and c == self.n - 1:\n            self.res.append(curr)\n            return\n\n        seen.add((r, c))\n        self.helper(r + 1, c, curr + \"D\")\n        self.helper(r - 1, c, curr + \"U\")\n        self.helper(r, c + 1, curr + \"R\")\n        self.helper(r, c - 1, curr + \"L\")\n        seen.remove((r, c))\n\n    def is_valid(self, r, c, seen):\n        return not (\n            r &lt; 0\n            or c &lt; 0\n            or r &gt;= self.n\n            or c &gt;= self.n\n            or (r, c) in seen\n            or not self.mat[r][c]\n        )\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/backtracking/#word-break-print-all-ways","title":"Word Break (print all ways)","text":"<p>\u2753: You are given a non-empty string S containing no spaces\u2019 and a dictionary of non-empty strings (say the list of words). You are supposed to construct and return all possible sentences after adding spaces in the originally given string \u2018S\u2019, such that each word in a sentence exists in the given dictionary.</p> <p>Note : The same word in the dictionary can be used multiple times to make sentences. Assume that the dictionary does not contain duplicate words.</p> <p>Example: 1 6 god is now no where here godisnowherenowhere  </p> <p>Output: god is no where no where god is no where now here god is now here no where god is now here now here  </p> <pre><code>class Solution:\n    def wordBreak(self, s, dictionary):\n        self.s = s\n        self.n = len(s)\n        self.words = set(dictionary)\n        self.res = []\n        self.helper()\n        return self.res\n\n    def helper(self, curr_ind=0, curr=[]):\n        if curr_ind == self.n:\n            self.res.append(curr[:])\n            return\n\n        for i in range(curr_ind, self.n):\n            if self.s[curr_ind : i + 1] in self.words:\n                curr.append(self.s[curr_ind : i + 1])\n                self.helper(i + 1)\n                curr.pop()\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"recursion/recursion/","title":"Recursion","text":""},{"location":"recursion/recursion/#sum-of-all-subsets","title":"Sum of all Subsets","text":"<p>\u2753: Given an array print all the sum of the subset generated from it, in the increasing order. Example: Input:  N = 3, arr[] = {5,2,1} Output: 0,1,2,3,5,6,7,8 Explanation: We have to find all the subset\u2019s sum and print them.in this case the generated subsets are [ [], [1], [2], [2,1], [5], [5,1], [5,2]. [5,2,1],so the sums we get will be  0,1,2,3,5,6,7,8.  </p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def subsetSums(self, arr):\n        self.res = []\n        self.arr = arr\n        self.n = len(arr)\n        self.helper()\n        return self.res\n\n    def helper(self, ind=0, curr=0):\n        if ind == self.n:\n            self.res.append(curr)\n            return\n\n        self.helper(ind + 1, curr + self.arr[ind])\n        self.helper(ind + 1, curr)\n</code></pre> <pre><code>fn subset_sums(nums: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut res: Vec&lt;i32&gt; = Vec::new();\n    helper(0, 0, nums, &amp;mut res);\n\n    res.sort();\n    res\n}\n\nfn helper(ind: usize, curr_sum: i32, nums: &amp;Vec&lt;i32&gt;, res: &amp;mut Vec&lt;i32&gt;) {\n    if ind == nums.len() {\n        res.push(curr_sum);\n        return;\n    }\n\n    helper(ind + 1, curr_sum + nums[ind], nums, res);\n    helper(ind + 1, curr_sum, nums, res);\n}\n\nfn main() {\n    assert_eq!(subset_sums(&amp;vec![2, 3]), vec![0, 2, 3, 5]);\n    assert_eq!(subset_sums(&amp;vec![1, 2, 1]), vec![0, 1, 1, 2, 2, 3, 3, 4]);\n    assert_eq!(subset_sums(&amp;vec![5, 6, 7]), vec![0, 5, 6, 7, 11, 12, 13, 18]);\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/recursion/#print-all-the-unique-subsets","title":"Print all the Unique Subsets","text":"<p>\u2753: Given an array of integers that may contain duplicates the task is to return all possible subsets. Return only unique subsets and they can be in any order.  Example: Input: [1,2,2] Output: [[ ],[1],[1,2],[1,2,2],[2],[2,2]] Explanation: We can have subsets ranging from  length 0 to 3. which are listed above. Also the subset [1,2] appears twice but is printed only once as we require only unique subsets.   </p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:\n        self.res = set()\n        self.nums = nums\n        self.n = len(nums)\n        self.helper()\n        return list(self.res)\n\n    def helper(self, ind=0, curr=[]):\n        if ind == self.n:\n            self.res.add(tuple(sorted(curr)))\n            return\n\n        curr.append(self.nums[ind])\n        self.helper(ind + 1, curr)\n\n        curr.pop()\n        self.helper(ind + 1, curr)\n</code></pre> <pre><code>use std::collections::HashSet;\n\nimpl Solution {\n    pub fn subsets_with_dup(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let mut nums = nums;\n        nums.sort();\n        let mut res: HashSet&lt;Vec&lt;i32&gt;&gt; = HashSet::new();\n        let mut curr: Vec&lt;i32&gt; = Vec::new();\n        Solution::helper(0, &amp;mut curr, &amp;nums, &amp;mut res);\n\n        let mut vec_res: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();\n\n        for i in res {\n            vec_res.push(i);\n        }\n\n        vec_res\n    }\n\n    fn helper(ind: usize, curr: &amp;mut Vec&lt;i32&gt;, nums: &amp;Vec&lt;i32&gt;, res: &amp;mut HashSet&lt;Vec&lt;i32&gt;&gt;) {\n        if ind == nums.len() {\n            res.insert(curr.clone());\n            return;\n        }\n\n        curr.push(nums[ind]);\n        Solution::helper(ind + 1, curr, nums, res);\n\n        curr.pop();\n        Solution::helper(ind + 1, curr, nums, res);\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/recursion/#combination-sum-1","title":"Combination Sum - 1","text":"<p>\u2753: Given an array of distinct integers and a target, you have to return the list of all unique combinations where the chosen numbers sum to target. You may return the combinations in any order.  </p> <p>The same number may be chosen from the given array an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p> <p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p> <p>Example: Input: array = [2,3,6,7], target = 7</p> <p>Output: [[2,2,3],[7]]</p> <p>Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.              7 is a candidate, and 7 = 7.              These are the only two combinations. </p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:\n        self.res = []\n        self.candidates = candidates\n        self.n = len(candidates)\n        self.target = target\n        self.helper()\n        return self.res\n\n    def helper(self, ind=0, curr=[], curr_sum=0):\n        if curr_sum == self.target:\n            self.res.append(curr[:])\n            return\n\n        if ind == self.n or curr_sum &gt; self.target:\n            return\n\n        curr.append(self.candidates[ind])\n        self.helper(ind, curr, curr_sum + self.candidates[ind])\n\n        curr.pop()\n        self.helper(ind + 1, curr, curr_sum)\n</code></pre> <pre><code>impl Solution {\n    pub fn combination_sum(candidates: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n\n        let mut res: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();\n        let mut curr: Vec&lt;i32&gt; = Vec::new();\n        Solution::helper(0, 0, &amp;mut curr, &amp;candidates, target, &amp;mut res);\n\n        res\n\n    }\n\n    fn helper(ind: usize, curr_sum: i32, curr: &amp;mut Vec&lt;i32&gt;, candidates: &amp;Vec&lt;i32&gt;, target: i32, res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;){\n\n        if curr_sum == target{\n            res.push(curr.clone());\n            return;\n        }\n\n        if curr_sum &gt; target || ind == candidates.len(){\n            return;\n        }\n\n        curr.push(candidates[ind]);\n        Solution::helper(ind, curr_sum + candidates[ind], curr, candidates, target, res);\n\n        curr.pop();\n        Solution::helper(ind+1, curr_sum, curr, candidates, target, res);\n\n\n\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/recursion/#combination-sum-2","title":"Combination Sum - 2","text":"<p>\u2753: Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination.</p> <p>Note: The solution set must not contain duplicate combinations.</p> <p>Example: Input: candidates = [10,1,2,7,6,1,5], target = 8</p> <p>Output:  [[1,1,6],[1,2,5],[1,7],[2,6]]</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:\n        self.res = set()\n        self.candidates = sorted(candidates)\n        self.n = len(candidates)\n        self.target = target\n        self.helper()\n        return list(self.res)\n\n    def helper(self, ind=0, curr=[], curr_sum=0):\n        if curr_sum == self.target:\n            self.res.add(tuple(curr[:]))\n            return\n\n        if ind == self.n or curr_sum &gt; self.target:\n            return\n\n        curr.append(self.candidates[ind])\n        self.helper(ind + 1, curr, curr_sum + self.candidates[ind])\n\n        curr.pop()\n        for i in range(ind + 1, self.n):\n            if self.candidates[i] != self.candidates[ind]:\n                self.helper(i, curr, curr_sum)\n                break\n</code></pre> <pre><code>use std::collections::HashSet;\n\nimpl Solution {\n    pub fn combination_sum2(candidates: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let mut candidates = candidates;\n        candidates.sort();\n\n        let mut res: HashSet&lt;Vec&lt;i32&gt;&gt; = HashSet::new();\n        let mut curr: Vec&lt;i32&gt; = Vec::new();\n        Solution::helper(0, 0, &amp;mut curr, &amp;candidates, target, &amp;mut res);\n\n        let mut res_vec: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();\n        for i in res {\n            res_vec.push(i);\n        }\n\n        res_vec\n    }\n\n    fn helper(\n        ind: usize,\n        curr_sum: i32,\n        curr: &amp;mut Vec&lt;i32&gt;,\n        candidates: &amp;Vec&lt;i32&gt;,\n        target: i32,\n        res: &amp;mut HashSet&lt;Vec&lt;i32&gt;&gt;,\n    ) {\n        if curr_sum == target {\n            res.insert(curr.clone());\n            return;\n        }\n\n        if curr_sum &gt; target || ind == candidates.len() {\n            return;\n        }\n\n        curr.push(candidates[ind]);\n        Solution::helper(\n            ind + 1,\n            curr_sum + candidates[ind],\n            curr,\n            candidates,\n            target,\n            res,\n        );\n\n        curr.pop();\n        for i in ind + 1..candidates.len() {\n            if candidates[i] != candidates[ind] {\n                Solution::helper(i, curr_sum, curr, candidates, target, res);\n                break;\n            }\n        }\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/recursion/#palindrome-partitioning","title":"Palindrome Partitioning","text":"<p>\u2753: You are given a string s, partition it in such a way that every substring is a palindrome. Return all such palindromic partitions of s.</p> <p>Example: Input: s = \u201caab\u201d</p> <p>Output: [ [\"a\",\"a\",\"b\"], [\"aa\",\"b\"] ]   </p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def partition(self, s: str) -&gt; List[List[str]]:\n        self.res = []\n        self.s = s\n        self.n = len(s)\n        self.helper()\n        return self.res\n\n    def helper(self, ind=0, curr=[]):\n        if ind == self.n:\n            self.res.append(curr[:])\n            return\n\n        for i in range(ind, self.n):\n            curr_string = self.s[ind : i + 1]\n            if curr_string == curr_string[::-1]:\n                curr.append(curr_string)\n                self.helper(i + 1, curr)\n                curr.pop()\n</code></pre> <pre><code>impl Solution {\n    pub fn partition(s: String) -&gt; Vec&lt;Vec&lt;String&gt;&gt; {\n        let mut res: Vec&lt;Vec&lt;String&gt;&gt; = Vec::new();\n        let mut curr: Vec&lt;String&gt; = Vec::new();\n        Solution::helper(0, &amp;mut curr, &amp;s, &amp;mut res);\n        res\n    }\n\n    fn helper(ind: usize, curr: &amp;mut Vec&lt;String&gt;, s: &amp;String, res: &amp;mut Vec&lt;Vec&lt;String&gt;&gt;) {\n        if ind == s.len() {\n            res.push(curr.clone());\n            return;\n        }\n\n        for i in ind + 1..=s.len() {\n            if s[ind..i] == s[ind..i].chars().rev().collect::&lt;String&gt;() {\n                curr.push(s[ind..i].to_string());\n                Solution::helper(i, curr, s, res);\n                curr.pop();\n            }\n        }\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"recursion/recursion/#find-k-th-permutation-sequence","title":"Find K-th Permutation Sequence","text":"<p>Coming Soon</p>"},{"location":"stacks_and_queues/stacks_and_queues_1/","title":"Part1","text":""},{"location":"stacks_and_queues/stacks_and_queues_1/#check-for-balanced-parentheses","title":"Check for Balanced Parentheses","text":"<p>\u2753: Check Balanced Parentheses. Given string str containing just the characters '(', ')', '{', '}', '[' and ']', check if the input string is valid and return true if the string is balanced otherwise return false.   </p> <p>Example: Input: str = \u201c( )[ { } ( ) ]\u201d</p> <p>Output: True</p> <p>Explanation: As every open bracket has its corresponding  close bracket. Match parentheses are in correct order  hence they are balanced.</p> <p>\ud83e\udde0: 1. Iterate through string, if opened brace is found append it to the stack. 2. If close brace if found, stack top element should be corresponding open brace. 3. If stack is empty or top element is a mismatch, return False. 4. Else pop the top element and continue. 5. At the end of iteration, stack should be empty.  </p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n        stack = []\n        close_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for i in s:\n            if i not in close_map:\n                stack.append(i)\n                continue\n\n            if not stack:\n                return False\n            if stack.pop() != close_map[i]:\n                return False\n\n        return stack == []\n</code></pre> <pre><code>use std::collections::HashMap;\n\nimpl Solution {\n    pub fn is_valid(s: String) -&gt; bool {\n        let close_map: HashMap&lt;char, char&gt; = HashMap::from([(']', '['), (')', '('), ('}', '{')]);\n        let mut stack: Vec&lt;char&gt; = vec![];\n\n        for c in s.chars() {\n            if !close_map.contains_key(&amp;c) {\n                stack.push(c);\n                continue;\n            }\n\n            if stack.len() == 0 || stack.pop().unwrap() != *close_map.get(&amp;c).unwrap() {\n                return false;\n            }\n        }\n\n        stack.len() == 0\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"stacks_and_queues/stacks_and_queues_1/#next-greater-element-using-stack","title":"Next Greater Element Using Stack","text":"<p>\u2753: The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.</p> <p>You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.</p> <p>For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.</p> <p>Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.</p> <p>Example: Input: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. - 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3. - 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.  </p> <p>\ud83e\udde0: 1. Use stack to find nge. 2. Store nge as hash map because we need nge for corresponding elements from nums1. 3. Return result array using nge map.</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:\n        nge = {}\n        stack = []\n\n        for num in nums2[::-1]:\n            while stack and stack[-1] &lt;= num:\n                stack.pop()\n\n            nge[num] = stack[-1] if stack else -1\n            stack.append(num)\n\n        return [nge[num] for num in nums1]\n</code></pre> <pre><code>use std::collections::HashMap;\n\nimpl Solution {\n    pub fn next_greater_element(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n        let mut stack: Vec&lt;i32&gt; = vec![];\n        let mut nge_map: HashMap&lt;i32, i32&gt; = HashMap::new();\n\n        for num in nums2.iter().rev() {\n            while !stack.is_empty() &amp;&amp; stack.last().unwrap() &lt;= num {\n                stack.pop();\n            }\n\n            nge_map.insert(*num, *stack.last().unwrap_or(&amp;-1));\n            stack.push(*num);\n        }\n\n        Vec::from_iter(nums1.iter().map(|num| nge_map[num]))\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"stacks_and_queues/stacks_and_queues_2/","title":"Part2","text":""},{"location":"stacks_and_queues/stacks_and_queues_2/#next-smaller-element","title":"Next Smaller Element","text":"<p>\ud83e\udde0: 1. Use stack. Iterate through items and remove items from stack whose value is greater than or equal to current num.  2. Next smaller element is element present in top of stack. If stack is empty, there is not next smaller element.  </p> \ud83d\udc0d\ud83e\udd80 <pre><code>def nextSmallerElement(A, n):\n    stack = []\n    res = []\n    for a in A[::-1]:\n        while stack and stack[-1] &gt;= a:\n            stack.pop()\n        res.append(stack[-1] if stack else -1)\n        stack.append(a)\n\n    return res[::-1]\n</code></pre> <pre><code>fn nse(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut stack: Vec&lt;i32&gt; = vec![];\n    let mut res: Vec&lt;i32&gt; = vec![];\n\n    for num in nums.iter().rev() {\n        while !stack.is_empty() &amp;&amp; stack.last().unwrap() &gt;= num {\n            stack.pop();\n        }\n        res.push(*stack.last().unwrap_or(&amp;-1));\n        stack.push(*num);\n    }\n\n    res.reverse();\n    res\n}\n\nfn main() {\n    assert_eq!(nse(vec![4, 5, 2, 10, 8]), vec![2, 2, -1, 8, -1]);\n    assert_eq!(nse(vec![3, 2, 1]), vec![2, 1, -1]);\n    assert_eq!(nse(vec![1, 2, 3]), vec![-1, -1, -1]);\n}\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"stacks_and_queues/stacks_and_queues_2/#largest-rectangle-in-a-histogram","title":"Largest rectangle in a histogram","text":"<p>\u2753: Given an array of integers heights representing the histogram's bar height where the width of each bar is 1  return the area of the largest rectangle in histogram. Example: Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.</p> <p></p> <p>\ud83e\udde0: For every height, possible rectangle width is <code>nse-pse-1</code></p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def largestRectangleArea(self, heights: list[int]) -&gt; int:\n        nse_arr = self.nse(heights)\n        pse_arr = self.pse(heights)\n\n        res = 0\n        for i in range(len(heights)):\n            res = max(res, heights[i] * (nse_arr[i] - pse_arr[i] - 1))\n        return res\n\n    def nse(self, heights):\n        res = []\n        stack = []\n        for ind in range(len(heights) - 1, -1, -1):\n            height = heights[ind]\n\n            while stack and heights[stack[-1]] &gt;= height:\n                stack.pop()\n            res.append(stack[-1] if stack else len(heights))\n            stack.append(ind)\n\n        return res[::-1]\n\n    def pse(self, heights):\n        res = []\n        stack = []\n        for ind, height in enumerate(heights):\n            while stack and heights[stack[-1]] &gt;= height:\n                stack.pop()\n            res.append(stack[-1] if stack else -1)\n            stack.append(ind)\n\n        return res\n</code></pre> <pre><code>use std::cmp::max;\n\nimpl Solution {\n    pub fn largest_rectangle_area(heights: Vec&lt;i32&gt;) -&gt; i32 {\n        let nse_vec: Vec&lt;i32&gt; = Solution::nse(&amp;heights);\n        let pse_vec: Vec&lt;i32&gt; = Solution::pse(&amp;heights);\n\n        let mut res: i32 = 0;\n\n        for i in 0..heights.len() {\n            res = max(res, heights[i] * (nse_vec[i] - pse_vec[i] - 1))\n        }\n        res\n    }\n\n    pub fn nse(heights: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n        let mut res: Vec&lt;i32&gt; = vec![];\n        let mut stack: Vec&lt;i32&gt; = vec![];\n        let n: i32 = heights.len() as i32;\n\n        for ind in (0..heights.len()).rev() {\n            while !stack.is_empty() &amp;&amp; heights[*stack.last().unwrap() as usize] &gt;= heights[ind] {\n                stack.pop();\n            }\n            res.push(*stack.last().unwrap_or(&amp;n));\n            stack.push(ind as i32);\n        }\n        res.reverse();\n        res\n    }\n\n    pub fn pse(heights: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n        let mut res: Vec&lt;i32&gt; = vec![];\n        let mut stack: Vec&lt;i32&gt; = vec![];\n\n        for ind in 0..heights.len() {\n            while !stack.is_empty() &amp;&amp; heights[*stack.last().unwrap() as usize] &gt;= heights[ind] {\n                stack.pop();\n            }\n            res.push(*stack.last().unwrap_or(&amp;-1));\n            stack.push(ind as i32);\n        }\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"stacks_and_queues/stacks_and_queues_2/#sliding-window-maximum","title":"Sliding Window Maximum","text":"<p>\u2753: Given an array of integers arr, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p> <p>Example: Input: arr = [4,0,-1,3,5,3,6,8], k = 3</p> <p>Output: [4,3,5,5,6,8]</p> <p>Explanation: </p> <p>Window position                   Max ------------------------         ----- [4  0  -1] 3  5  3  6  8           - 4  4 [0  -1  3] 5  3  6  8           - 3  4  0 [-1  3  5] 3  6  8           - 5  4  0  -1 [3  5  3] 6  8           - 5  4  0  -1  3 [5  3  6] 8           - 6  4  0  -1  3  5 [3  6  8]          - 8  </p> <p>For each window of size k=3, we find the maximum element in the window and add it to our output array.</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:\n        deque = []\n        n = len(nums)\n        res = []\n\n        for ind, num in enumerate(nums):\n            if deque and deque[0] &lt;= ind - k:\n                deque.pop(0)\n\n            while deque and nums[deque[-1]] &lt; num:\n                deque.pop()\n\n            deque.append(ind)\n\n            if ind &gt;= k - 1:\n                res.append(nums[deque[0]])\n\n        return res\n</code></pre> <pre><code>impl Solution {\n    pub fn max_sliding_window(nums: Vec&lt;i32&gt;, k: i32) -&gt; Vec&lt;i32&gt; {\n        let mut deque: Vec&lt;usize&gt; = Vec::new();\n        let mut res: Vec&lt;i32&gt; = Vec::new();\n\n        for (ind, num) in nums.iter().enumerate() {\n            if !deque.is_empty() &amp;&amp; deque[0] as i32 &lt;= ind as i32 - k {\n                deque.remove(0);\n            }\n\n            while !deque.is_empty() &amp;&amp; nums[*deque.last().unwrap()] &lt;= *num {\n                deque.pop();\n            }\n\n            deque.push(ind);\n            if ind &gt;= (k - 1) as usize {\n                res.push(nums[deque[0]]);\n            }\n        }\n\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"stacks_and_queues/stacks_and_queues_2/#implement-min-stack","title":"Implement Min Stack","text":"<p>\u2753: Implement Min Stack | O(2N) and O(N) Space Complexity. Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p> <p>Example: Input Format:[\"MinStack\", \"push\", \"push\", \"push\", \"getMin\", \"pop\", \"top\", \"getMin\"] [ [ ], [-2], [0], [-3], [ ], [ ], [ ], [ ] ]</p> <p>Result: [null, null, null, null, -3, null, 0, -2]</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.mini_stack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        if self.mini_stack:\n            self.mini_stack.append(min(self.mini_stack[-1], val))\n        else:\n            self.mini_stack.append(val)\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n        self.mini_stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1]\n\n    def getMin(self) -&gt; int:\n        return self.mini_stack[-1]\n</code></pre> <pre><code>use std::cmp::min;\n\nstruct MinStack {\n    stack: Vec&lt;i32&gt;,\n    min_stack: Vec&lt;i32&gt;,\n}\n\nimpl MinStack {\n    fn new() -&gt; Self {\n        MinStack {\n            stack: Vec::new(),\n            min_stack: Vec::new(),\n        }\n    }\n\n    fn push(&amp;mut self, val: i32) {\n        if self.stack.is_empty() {\n            self.min_stack.push(val);\n        } else {\n            let top = self.min_stack.last().unwrap();\n            self.min_stack.push(min(*top, val));\n        }\n        self.stack.push(val);\n    }\n\n    fn pop(&amp;mut self) {\n        self.stack.pop();\n        self.min_stack.pop();\n    }\n\n    fn top(&amp;self) -&gt; i32 {\n        *self.stack.last().unwrap()\n    }\n\n    fn get_min(&amp;self) -&gt; i32 {\n        *self.min_stack.last().unwrap()\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"stacks_and_queues/stacks_and_queues_2/#rotten-orange-using-bfs","title":"Rotten Orange (Using BFS)","text":"<p>\u2753: You will be given an m x n grid, where each cell has the following values : </p> <p>2  -  represents a rotten orange 1  -  represents a Fresh orange 0  -  represents an Empty Cell Every minute, if a Fresh Orange is adjacent to a Rotten Orange in 4-direction ( upward, downwards, right, and left ) it becomes Rotten. </p> <p>Return the minimum number of minutes required such that none of the cells has a Fresh Orange. If it's not possible, return -1.</p> <p>Example:  </p> <p>Input: grid = [[2,1,1],[1,1,0],[0,1,1]] Output: 4</p> <p></p> <p>\ud83e\udde0: Use BFS</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class Solution:\n    def orangesRotting(self, grid: list[list[int]]) -&gt; int:\n        n = len(grid)\n        m = len(grid[0])\n\n        queue = []\n        bad_oranges = 0\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 2:\n                    bad_oranges += 1\n                    queue.append((i, j))\n\n        res = -1\n\n        while queue:\n            for _ in range(len(queue)):\n                curr_i, curr_j = queue.pop(0)\n                for i, j in zip([-1, 0, 1, 0], [0, -1, 0, 1]):\n                    if (\n                        self.is_valid(curr_i + i, curr_j + j, n, m)\n                        and grid[curr_i + i][curr_j + j] == 1\n                    ):\n                        grid[curr_i + i][curr_j + j] = 2\n                        queue.append((curr_i + i, curr_j + j))\n\n            res += 1\n\n        for item in grid:\n            if 1 in item:\n                return -1\n\n        if bad_oranges == 0:\n            return 0\n\n        return res\n\n    def is_valid(self, i, j, n, m):\n        return (0 &lt;= i &lt; n) and (0 &lt;= j &lt; m)\n</code></pre> <pre><code>impl Solution {\n    pub fn oranges_rotting(grid: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {\n        let mut grid = grid;\n        let mut queue: Vec&lt;(i32, i32)&gt; = Vec::new();\n        let mut rotten = 0;\n        let (n, m) = (grid.len() as i32, grid[0].len() as i32);\n\n        for i in 0..n {\n            for j in 0..m {\n                let i = i as usize;\n                let j = j as usize;\n                if grid[i][j] == 2 {\n                    rotten += 1;\n                    queue.push((i as i32, j as i32));\n                }\n            }\n        }\n\n        let mut res = -1;\n\n        while !queue.is_empty() {\n            for _ in 0..queue.len() {\n                let curr = queue.remove(0);\n\n                let x_iter: Vec&lt;i32&gt; = vec![1, 0, -1, 0];\n                let y_iter: Vec&lt;i32&gt; = vec![0, 1, 0, -1];\n\n                for i in 0..4 {\n                    let new_i = curr.0 + x_iter[i];\n                    let new_j = curr.1 + y_iter[i];\n                    if 0 &lt;= new_i\n                        &amp;&amp; new_i &lt; n\n                        &amp;&amp; 0 &lt;= new_j\n                        &amp;&amp; new_j &lt; m\n                        &amp;&amp; grid[new_i as usize][new_j as usize] == 1\n                    {\n                        grid[new_i as usize][new_j as usize] = 2;\n                        queue.push((new_i, new_j));\n                    }\n                }\n            }\n            res += 1;\n        }\n\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i as usize][j as usize] == 1 {\n                    return -1;\n                }\n            }\n        }\n        if rotten == 0 {\n            return 0;\n        }\n\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcd8 \ud83d\udcbb</p>"},{"location":"stacks_and_queues/stacks_and_queues_2/#stock-span-problem","title":"Stock span problem","text":"<p>\u2753: Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.</p> <p>The span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.</p> <p>For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.</p> <p>Implement the StockSpanner class:</p> <p>StockSpanner() Initializes the object of the class. int next(int price) Returns the span of the stock's price given that today's price is price.</p> <p>Example: Input [\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"] [[], [100], [80], [60], [70], [60], [75], [85]] Output [null, 1, 1, 1, 2, 1, 4, 6]</p> <p>\ud83e\udde0: Find pge</p> \ud83d\udc0d\ud83e\udd80 <pre><code>class StockSpanner:\n    def __init__(self):\n        self.prices = []\n        self.pge = []\n\n    def next(self, price: int) -&gt; int:\n        self.prices.append(price)\n        n = len(self.prices)\n\n        while self.pge and self.prices[self.pge[-1]] &lt;= price:\n            self.pge.pop()\n\n        res = n\n        if self.pge:\n            res = n - self.pge[-1] - 1\n\n        self.pge.append(n - 1)\n\n        return res\n</code></pre> <pre><code>struct StockSpanner {\n    stocks: Vec&lt;i32&gt;,\n    pge: Vec&lt;i32&gt;,\n}\n\nimpl StockSpanner {\n    fn new() -&gt; Self {\n        StockSpanner {\n            stocks: Vec::new(),\n            pge: Vec::new(),\n        }\n    }\n\n    fn next(&amp;mut self, price: i32) -&gt; i32 {\n        self.stocks.push(price);\n        let n = self.stocks.len() as i32;\n\n        while !self.pge.is_empty() &amp;&amp; self.stocks[*self.pge.last().unwrap() as usize] &lt;= price {\n            self.pge.pop();\n        }\n        let mut res = n;\n\n        if !self.pge.is_empty() {\n            res = n - *self.pge.last().unwrap() - 1;\n        }\n        self.pge.push(n - 1);\n\n        res\n    }\n}\n</code></pre> <p>\ud83d\udcbb</p>"},{"location":"stacks_and_queues/stacks_and_queues_2/#the-celebrity-problem","title":"The Celebrity Problem","text":"<p>\u2753: A celebrity is a person who is known by everyone else at the party but does not know anyone in return. Given a square matrix M of size N x N where M[i][j] is 1 if person i knows person j, and 0 otherwise, determine if there is a celebrity at the party. Return the index of the celebrity or -1 if no such person exists.</p> <p>Note that M[i][i] is always 0.</p> <p>Example: Input: M = [ [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0] ]</p> <p>Output: 1</p> <p>Explanation: Person 1 does not know anyone and is known by persons 0, 2, and 3. Therefore, person 1 is the celebrity.</p> \ud83d\udc0d\ud83e\udd80 <pre><code>from collections import defaultdict\n\n\nclass Solution:\n    def celebrity(self, M):\n        i_know = defaultdict(int)\n        know_me = defaultdict(int)\n\n        n = len(M)\n        m = len(M[0])\n\n        for i in range(n):\n            for j in range(m):\n                if M[i][j]:\n                    i_know[i] += 1\n                    know_me[j] += 1\n\n        for i in range(n):\n            if i_know[i] == 0 and know_me[i] == n - 1:\n                return i\n\n        return -1\n</code></pre> <pre><code>use std::collections::HashMap;\n\nfn celebrity(matrix: &amp;[[i32; 4]; 4]) -&gt; i32 {\n    let mut i_know: HashMap&lt;usize, usize&gt; = HashMap::new();\n    let mut know_me: HashMap&lt;usize, usize&gt; = HashMap::new();\n    let (m, n) = (matrix.len(), matrix[0].len());\n\n    for i in 0..m {\n        for j in 0..n {\n            if matrix[i][j] == 1 {\n                i_know.entry(i).and_modify(|e| *e += 1).or_insert(1);\n                know_me.entry(j).and_modify(|e| *e += 1).or_insert(1);\n            }\n        }\n    }\n\n    for i in 0..n {\n        if !i_know.contains_key(&amp;i) &amp;&amp; know_me[&amp;i] == n - 1 {\n            return i as i32;\n        }\n    }\n\n    -1\n}\n\nfn main() {\n    let matrix = [[0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0]];\n    assert_eq!(celebrity(&amp;matrix), 1);\n}\n</code></pre>"}]}